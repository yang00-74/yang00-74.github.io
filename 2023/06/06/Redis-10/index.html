<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析 | 谈谈1974</title><meta name="author" content="nathan.yang"><meta name="copyright" content="nathan.yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主从复制中 Master 节点的处理Redis 主从复制 一节中粗略介绍过 Redis 的主从复制存在两种模式，以下则是 Master 节点对于主从复制的处理：   接收 Slave 节点的 psync 命令 判断是否可以执行部分复制，可以的话回复 +CONTINUE 给 Slave 节点，并将缓冲区命令直接发送给 Slave 节点，完成同步；不可以执行部分复制，只能全量复制，则回复 +FULLR">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析">
<meta property="og:url" content="https://yang00-74.github.io/2023/06/06/Redis-10/index.html">
<meta property="og:site_name" content="谈谈1974">
<meta property="og:description" content="主从复制中 Master 节点的处理Redis 主从复制 一节中粗略介绍过 Redis 的主从复制存在两种模式，以下则是 Master 节点对于主从复制的处理：   接收 Slave 节点的 psync 命令 判断是否可以执行部分复制，可以的话回复 +CONTINUE 给 Slave 节点，并将缓冲区命令直接发送给 Slave 节点，完成同步；不可以执行部分复制，只能全量复制，则回复 +FULLR">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-06-06T12:10:29.000Z">
<meta property="article:modified_time" content="2023-06-08T09:49:48.563Z">
<meta property="article:author" content="nathan.yang">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="分布式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/drogan.jpg"><link rel="canonical" href="https://yang00-74.github.io/2023/06/06/Redis-10/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-08 17:49:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="谈谈1974"><span class="site-name">谈谈1974</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T12:10:29.000Z" title="发表于 2023-06-06 20:10:29">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-08T09:49:48.563Z" title="更新于 2023-06-08 17:49:48">2023-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="主从复制中-Master-节点的处理"><a href="#主从复制中-Master-节点的处理" class="headerlink" title="主从复制中 Master 节点的处理"></a>主从复制中 Master 节点的处理</h1><p><a href="https://yang00-74.github.io/2023/06/05/Redis-concept/#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">Redis 主从复制</a> 一节中粗略介绍过 Redis 的主从复制存在两种模式，以下则是 Master 节点对于主从复制的处理：</p>
<blockquote>
<ol>
<li>接收 Slave 节点的 psync 命令</li>
<li>判断是否可以执行部分复制，可以的话回复 <code>+CONTINUE</code> 给 Slave 节点，并将缓冲区命令直接发送给 Slave 节点，完成同步；不可以执行部分复制，只能全量复制，则回复 <code>+FULLRESYNC</code> 给 Slave 节点，根据情况做下一步处理</li>
<li>Master 节点存在可以复用的 rdb 数据，则直接将其发送给 Slave 节点，否则新起一个进程异步生成 rdb 数据</li>
<li>如果 Slave 节点同步配置可以直接通过 socket 发送 rdb 数据则直接发送，否则 Master 节点需要保存 rdb 数据到 rdb 文件</li>
<li>Master 节点定时任务周期检查 rdb 文件是否保存完毕，完成则发送 rdb 文件到 Slave 节点</li>
<li>最后发送 rdb 文件生成过程中缓存的 redis 执行命令给 Slave 节点</li>
</ol>
</blockquote>
<p><img src="/../images/redis-10-1.jpeg" alt="在这里插入图片描述"></p>
<h1 id="处理流程分析"><a href="#处理流程分析" class="headerlink" title="处理流程分析"></a>处理流程分析</h1><p><img src="/../images/redis-10-2.png" alt="在这里插入图片描述"></p>
<h3 id="psync-命令的大致处理"><a href="#psync-命令的大致处理" class="headerlink" title="psync 命令的大致处理"></a>psync 命令的大致处理</h3><ol>
<li><p>Redis 中对 <code>psync</code> 命令的处理由 <code>replication.c#syncCommand()</code> 函数完成，这个函数的实现源码较为复杂，不过大致逻辑可分为以下几步：</p>
<blockquote>
<ol>
<li>首先是一般性的校验，比如验证接收 <code>psync</code> 命令的服务端是从节点的话，直接返回；另外如果当前服务端的主节点 host 有值但是同步状态不在 <code>REPL_STATE_CONNECTED</code> 时，说明当前从节点没有与主节点连接上，也直接返回</li>
<li>接下来解析传输过来的命令，如果是 <code>psync</code> 命令，则调用 <code>masterTryPartialResynchronization()</code> 函数尝试进行从节点部分复制</li>
<li>主节点接收的命令不是  <code>psync</code>  或者从节点部分复制失败了，则需要进行全量复制。如果这是主节点第一次全量复制，还需要改变<code>server.replid</code>，并创建复制缓冲区</li>
<li>此时主节点需要根据自身的场景做处理：<ol>
<li>如果此时已经有保存 rdb 数据的 <code>BGSAVE</code> 进程在运行，并且该进程会把 rdb 数据保存为 rdb 文件，则需要检查当前要求与主节点同步的从节点是否可以复用其他从节点即将传输的 rdb 数据，可以的话直接把 rdb 数据复制到当前从节点的缓存区，并调用 <code>replicationSetupSlaveForFullResync()</code> 函数通知 <code>+FULLRESYNC</code> 给从节点，主节点轮询到该从节点连接可写时会把 rdb 数据发送过去</li>
<li>如果此时已经有保存 rdb 数据的进程在运行，但是该进程生成的 rdb 数据会直接通过 socket 发送到对端，则这份 rdb 数据不可复用，当前从节点等待下一次 <code>BGSAVE</code> </li>
<li>如果此时没有保存 rdb 数据的进程在运行，并且从节点不支持直接通过 socket 接收 rdb 数据，则调用 <code>startBgsaveForReplication()</code> 函数启动一个进程后台保存 rdb 数据</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYNC and PSYNC command implemenation. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syncCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line"> <span class="comment">/* ignore SYNC if already slave or in monitor mode */</span></span><br><span class="line"> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Refuse SYNC requests if we are a slave but the link with our master</span></span><br><span class="line"><span class="comment">  * is not ok... */</span></span><br><span class="line"> <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) &#123;</span><br><span class="line">     addReplySds(c,sdsnew(<span class="string">&quot;-NOMASTERLINK Can&#x27;t SYNC while not connected with my master\r\n&quot;</span>));</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* SYNC can&#x27;t be issued when the server has pending data to send to</span></span><br><span class="line"><span class="comment">  * the client about already issued commands. We need a fresh reply</span></span><br><span class="line"><span class="comment">  * buffer registering the differences between the BGSAVE and the current</span></span><br><span class="line"><span class="comment">  * dataset, so that we can copy to other slaves if needed. */</span></span><br><span class="line"> <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">     addReplyError(c,<span class="string">&quot;SYNC and PSYNC are invalid with pending output&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> serverLog(LL_NOTICE,<span class="string">&quot;Replica %s asks for synchronization&quot;</span>,</span><br><span class="line">     replicationGetSlaveName(c));</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Try a partial resynchronization if this is a PSYNC command.</span></span><br><span class="line"><span class="comment">  * If it fails, we continue with usual full resynchronization, however</span></span><br><span class="line"><span class="comment">  * when this happens masterTryPartialResynchronization() already</span></span><br><span class="line"><span class="comment">  * replied with:</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * +FULLRESYNC &lt;replid&gt; &lt;offset&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * So the slave knows the new replid and offset to try a PSYNC later</span></span><br><span class="line"><span class="comment">  * if the connection with the master is lost. */</span></span><br><span class="line"> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">&quot;psync&quot;</span>)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">         server.stat_sync_partial_ok++;</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">/* No full resync needed, return. */</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="type">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Increment stats for failed PSYNCs, but only if the</span></span><br><span class="line"><span class="comment">          * replid is not &quot;?&quot;, as this is used by slaves to force a full</span></span><br><span class="line"><span class="comment">          * resync on purpose when they are not albe to partially</span></span><br><span class="line"><span class="comment">          * resync. */</span></span><br><span class="line">         <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span>) server.stat_sync_partial_err++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/* If a slave uses SYNC, we are dealing with an old implementation</span></span><br><span class="line"><span class="comment">      * of the replication protocol (like redis-cli --slave). Flag the client</span></span><br><span class="line"><span class="comment">      * so that we don&#x27;t expect to receive REPLCONF ACK feedbacks. */</span></span><br><span class="line">     c-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Full resynchronization. */</span></span><br><span class="line"> server.stat_sync_full++;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Setup the slave as one waiting for BGSAVE to start. The following code</span></span><br><span class="line"><span class="comment">  * paths will change the state if we handle the slave differently. */</span></span><br><span class="line"> c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line"> <span class="keyword">if</span> (server.repl_disable_tcp_nodelay)</span><br><span class="line">     connDisableTcpNoDelay(c-&gt;conn); <span class="comment">/* Non critical if it fails. */</span></span><br><span class="line"> c-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line"> c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line"> listAddNodeTail(server.slaves,c);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create the replication backlog if needed. */</span></span><br><span class="line"> <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">1</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">/* When we create the backlog from scratch, we always use a new</span></span><br><span class="line"><span class="comment">      * replication ID and clear the ID2, since there is no valid</span></span><br><span class="line"><span class="comment">      * past history. */</span></span><br><span class="line">     changeReplicationId();</span><br><span class="line">     clearReplicationId2();</span><br><span class="line">     createReplicationBacklog();</span><br><span class="line">     serverLog(LL_NOTICE,<span class="string">&quot;Replication backlog created, my new &quot;</span></span><br><span class="line">                         <span class="string">&quot;replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                         server.replid, server.replid2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* CASE 1: BGSAVE is in progress, with disk target. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">     server.rdb_child_type == RDB_CHILD_TYPE_DISK)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">/* Ok a background save is in progress. Let&#x27;s check if it is a good</span></span><br><span class="line"><span class="comment">      * one for replication, i.e. if there is another slave that is</span></span><br><span class="line"><span class="comment">      * registering differences since the server forked to save. */</span></span><br><span class="line">     client *slave;</span><br><span class="line">     listNode *ln;</span><br><span class="line">     listIter li;</span><br><span class="line"></span><br><span class="line">     listRewind(server.slaves,&amp;li);</span><br><span class="line">     <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">         slave = ln-&gt;value;</span><br><span class="line">         <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* To attach this slave, we check that it has at least all the</span></span><br><span class="line"><span class="comment">      * capabilities of the slave that triggered the current BGSAVE. */</span></span><br><span class="line">     <span class="keyword">if</span> (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</span><br><span class="line">         <span class="comment">/* Perfect, the server is already registering differences for</span></span><br><span class="line"><span class="comment">          * another slave. Set the right state, and copy the buffer. */</span></span><br><span class="line">         copyClientOutputBuffer(c,slave);</span><br><span class="line">         replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</span><br><span class="line">         serverLog(LL_NOTICE,<span class="string">&quot;Waiting for end of BGSAVE for SYNC&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* No way, we need to wait for the next BGSAVE in order to</span></span><br><span class="line"><span class="comment">          * register differences. */</span></span><br><span class="line">         serverLog(LL_NOTICE,<span class="string">&quot;Can&#x27;t attach the replica to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* CASE 2: BGSAVE is in progress, with socket target. */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">/* There is an RDB child process but it is writing directly to</span></span><br><span class="line"><span class="comment">      * children sockets. We need to wait for the next BGSAVE</span></span><br><span class="line"><span class="comment">      * in order to synchronize. */</span></span><br><span class="line">     serverLog(LL_NOTICE,<span class="string">&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* CASE 3: There is no BGSAVE is progress. */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</span><br><span class="line">         <span class="comment">/* Diskless replication RDB child is created inside</span></span><br><span class="line"><span class="comment">          * replicationCron() since we want to delay its start a</span></span><br><span class="line"><span class="comment">          * few seconds to wait for more slaves to arrive. */</span></span><br><span class="line">         <span class="keyword">if</span> (server.repl_diskless_sync_delay)</span><br><span class="line">             serverLog(LL_NOTICE,<span class="string">&quot;Delay next BGSAVE for diskless SYNC&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* Target is disk (or the slave is not capable of supporting</span></span><br><span class="line"><span class="comment">          * diskless replication) and we don&#x27;t have a BGSAVE in progress,</span></span><br><span class="line"><span class="comment">          * let&#x27;s start one. */</span></span><br><span class="line">         <span class="keyword">if</span> (!hasActiveChildProcess()) &#123;</span><br><span class="line">             startBgsaveForReplication(c-&gt;slave_capa);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             serverLog(LL_NOTICE,</span><br><span class="line">                 <span class="string">&quot;No BGSAVE in progress, but another BG operation is active. &quot;</span></span><br><span class="line">                 <span class="string">&quot;BGSAVE for replication delayed&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><code>reolication.c#masterTryPartialResynchronization()</code> 函数负责从节点<font style=background-color:#f8f840>部分复制</font>的处理，其重要逻辑如下：</p>
<blockquote>
<ol>
<li>首先是参数检查，如果从节点带过来的 <code>master_replid</code> 和主节点的 <code>server.replid</code> 不相等，并且 <code>master_replid</code> 和主节点的 <code>server.replid2</code> 不相等，则不能进行部分复制</li>
<li>如果从节点带过来的复制偏移量 <code>psync_offset</code> 小于主节点复制缓存区起始点 <code>server.repl_backlog_off</code> 或者  <code>psync_offset</code> 大于主节点复制缓存区结束点，则也不能进行部分复制</li>
<li>排除了以上场景，则可以进行部分复制。这部分主要有以下几个操作：<ol>
<li>将从节点的同步状态标记为 <code>SLAVE_STATE_ONLINE</code>，并将其添加到主节点保存的从节点列表<code>server.slaves</code>的尾部</li>
<li>给从节点发送 <code>+CONTINUE</code> 通知其可以进行部分复制</li>
<li>调用 <code>addReplyReplicationBacklog()</code> 函数将主节点复制缓存区指定偏移量的数据添加到从节点的缓存区，等待其可写时发送过去</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">masterTryPartialResynchronization</span><span class="params">(client *c)</span> &#123;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> psync_offset, psync_len;</span><br><span class="line"> <span class="type">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line"> <span class="type">int</span> buflen;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Parse the replication offset asked by the slave. Go to full sync</span></span><br><span class="line"><span class="comment">  * on parse error: this should never happen but we try to handle</span></span><br><span class="line"><span class="comment">  * it in a robust way compared to aborting. */</span></span><br><span class="line"> <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;psync_offset,<span class="literal">NULL</span>) !=</span><br><span class="line">    C_OK) <span class="keyword">goto</span> need_full_resync;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Is the replication ID of this master the same advertised by the wannabe</span></span><br><span class="line"><span class="comment">  * slave via PSYNC? If the replication ID changed this master has a</span></span><br><span class="line"><span class="comment">  * different replication history, and there is no way to continue.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Note that there are two potentially valid replication IDs: the ID1</span></span><br><span class="line"><span class="comment">  * and the ID2. The ID2 however is only valid up to a specific offset. */</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(master_replid, server.replid) &amp;&amp;</span><br><span class="line">     (strcasecmp(master_replid, server.replid2) ||</span><br><span class="line">      psync_offset &gt; server.second_replid_offset))</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">/* Run id &quot;?&quot; is used by slaves that want to force a full resync. */</span></span><br><span class="line">     <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (strcasecmp(master_replid, server.replid) &amp;&amp;</span><br><span class="line">             strcasecmp(master_replid, server.replid2))</span><br><span class="line">         &#123;</span><br><span class="line">             serverLog(LL_NOTICE,<span class="string">&quot;Partial resynchronization not accepted: &quot;</span></span><br><span class="line">                 <span class="string">&quot;Replication ID mismatch (Replica asked for &#x27;%s&#x27;, my &quot;</span></span><br><span class="line">                 <span class="string">&quot;replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">                 master_replid, server.replid, server.replid2);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             serverLog(LL_NOTICE,<span class="string">&quot;Partial resynchronization not accepted: &quot;</span></span><br><span class="line">                 <span class="string">&quot;Requested offset for second ID was %lld, but I can reply &quot;</span></span><br><span class="line">                 <span class="string">&quot;up to %lld&quot;</span>, psync_offset, server.second_replid_offset);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         serverLog(LL_NOTICE,<span class="string">&quot;Full resync requested by replica %s&quot;</span>,</span><br><span class="line">             replicationGetSlaveName(c));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">goto</span> need_full_resync;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* We still have the data our slave is asking for? */</span></span><br><span class="line"> <span class="keyword">if</span> (!server.repl_backlog ||</span><br><span class="line">     psync_offset &lt; server.repl_backlog_off ||</span><br><span class="line">     psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</span><br><span class="line"> &#123;</span><br><span class="line">     serverLog(LL_NOTICE,</span><br><span class="line">         <span class="string">&quot;Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld).&quot;</span>, replicationGetSlaveName(c), psync_offset);</span><br><span class="line">     <span class="keyword">if</span> (psync_offset &gt; server.master_repl_offset) &#123;</span><br><span class="line">         serverLog(LL_WARNING,</span><br><span class="line">             <span class="string">&quot;Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;</span>, replicationGetSlaveName(c));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">goto</span> need_full_resync;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If we reached this point, we are able to perform a partial resync:</span></span><br><span class="line"><span class="comment">  * 1) Set client state to make it a slave.</span></span><br><span class="line"><span class="comment">  * 2) Inform the client we can continue with +CONTINUE</span></span><br><span class="line"><span class="comment">  * 3) Send the backlog data (from the offset to the end) to the slave. */</span></span><br><span class="line"> c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line"> c-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line"> c-&gt;repl_ack_time = server.unixtime;</span><br><span class="line"> c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line"> listAddNodeTail(server.slaves,c);</span><br><span class="line"> <span class="comment">/* We can&#x27;t use the connection buffers since they are used to accumulate</span></span><br><span class="line"><span class="comment">  * new commands at this stage. But we are sure the socket send buffer is</span></span><br><span class="line"><span class="comment">  * empty so this write will never fail actually. */</span></span><br><span class="line"> <span class="keyword">if</span> (c-&gt;slave_capa &amp; SLAVE_CAPA_PSYNC2) &#123;</span><br><span class="line">     buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;+CONTINUE %s\r\n&quot;</span>, server.replid);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;+CONTINUE\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (connWrite(c-&gt;conn,buf,buflen) != buflen) &#123;</span><br><span class="line">     freeClientAsync(c);</span><br><span class="line">     <span class="keyword">return</span> C_OK;</span><br><span class="line"> &#125;</span><br><span class="line"> psync_len = addReplyReplicationBacklog(c,psync_offset);</span><br><span class="line"> serverLog(LL_NOTICE,</span><br><span class="line">     <span class="string">&quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;</span>,</span><br><span class="line">         replicationGetSlaveName(c),</span><br><span class="line">         psync_len, psync_offset);</span><br><span class="line"> <span class="comment">/* Note that we don&#x27;t need to set the selected DB at server.slaveseldb</span></span><br><span class="line"><span class="comment">  * to -1 to force the master to emit SELECT, since the slave already</span></span><br><span class="line"><span class="comment">  * has this state from the previous connection with the master. */</span></span><br><span class="line"></span><br><span class="line"> refreshGoodSlavesCount();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Fire the replica change modules event. */</span></span><br><span class="line"> moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,</span><br><span class="line">                       REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> C_OK; <span class="comment">/* The caller can return, no full resync needed. */</span></span><br><span class="line"></span><br><span class="line">need_full_resync:</span><br><span class="line"> <span class="comment">/* We need a full resync for some reason... Note that we can&#x27;t</span></span><br><span class="line"><span class="comment">  * reply to PSYNC right now if a full SYNC is needed. The reply</span></span><br><span class="line"><span class="comment">  * must include the master offset at the time the RDB file we transfer</span></span><br><span class="line"><span class="comment">  * is generated, so we need to delay the reply to that moment. */</span></span><br><span class="line"> <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reolication.c#replicationSetupSlaveForFullResync()</code> 函数主要的作用发送 <code>+FULLRESYNC</code> 通知从节点需要进行<font style=background-color:#f8f840>全量复制</font>，没有其他的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">replicationSetupSlaveForFullResync</span><span class="params">(client *slave, <span class="type">long</span> <span class="type">long</span> offset)</span> &#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line"> <span class="type">int</span> buflen;</span><br><span class="line"></span><br><span class="line"> slave-&gt;psync_initial_offset = offset;</span><br><span class="line"> slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;</span><br><span class="line"> <span class="comment">/* We are going to accumulate the incremental changes for this</span></span><br><span class="line"><span class="comment">  * slave as well. Set slaveseldb to -1 in order to force to re-emit</span></span><br><span class="line"><span class="comment">  * a SELECT statement in the replication stream. */</span></span><br><span class="line"> server.slaveseldb = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Don&#x27;t send this reply to slaves that approached us with</span></span><br><span class="line"><span class="comment">  * the old SYNC command. */</span></span><br><span class="line"> <span class="keyword">if</span> (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</span><br><span class="line">     buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;+FULLRESYNC %s %lld\r\n&quot;</span>,</span><br><span class="line">                       server.replid,offset);</span><br><span class="line">     <span class="keyword">if</span> (connWrite(slave-&gt;conn,buf,buflen) != buflen) &#123;</span><br><span class="line">         freeClientAsync(slave);</span><br><span class="line">         <span class="keyword">return</span> C_ERR;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replication.c#startBgsaveForReplication()</code> 函数<font style=background-color:#f8f840>负责拉起一个保存 rdb 数据的任务</font>，其内部根据从节点的能力确定 rdb 数据的传输形式</p>
<blockquote>
<ol>
<li>如果主节点配置了直接通过 socket 发送 rdb 数据并且从节点也能够处理直接通过 socket 传输过来的 rdb 数据，则调用  <code>rdbSaveToSlavesSockets()</code> 函数生成并传输 rdb 数据，否则调用 <code>rdbSaveBackground()</code> 将 rdb 数据保存到 rdb 文件里</li>
<li>如果本次会生成 rdb 文件，则将主节点保存的从节点列表中处于<code>SLAVE_STATE_WAIT_BGSAVE_START</code>状态的从节点客户端都取出来，调用 <code>replicationSetupSlaveForFullResync()</code> 函数通知其<code>+FULLRESYNC</code>，也就是将进行全量复制</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">startBgsaveForReplication</span><span class="params">(<span class="type">int</span> mincapa)</span> &#123;</span><br><span class="line"> <span class="type">int</span> retval;</span><br><span class="line"> <span class="type">int</span> socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</span><br><span class="line"> listIter li;</span><br><span class="line"> listNode *ln;</span><br><span class="line"></span><br><span class="line"> serverLog(LL_NOTICE,<span class="string">&quot;Starting BGSAVE for SYNC with target: %s&quot;</span>,</span><br><span class="line">     socket_target ? <span class="string">&quot;replicas sockets&quot;</span> : <span class="string">&quot;disk&quot;</span>);</span><br><span class="line"></span><br><span class="line"> rdbSaveInfo rsi, *rsiptr;</span><br><span class="line"> rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line"> <span class="comment">/* Only do rdbSave* when rsiptr is not NULL,</span></span><br><span class="line"><span class="comment">  * otherwise slave will miss repl-stream-db. */</span></span><br><span class="line"> <span class="keyword">if</span> (rsiptr) &#123;</span><br><span class="line">     <span class="keyword">if</span> (socket_target)</span><br><span class="line">         retval = rdbSaveToSlavesSockets(rsiptr);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         retval = rdbSaveBackground(server.rdb_filename,rsiptr);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     serverLog(LL_WARNING,<span class="string">&quot;BGSAVE for replication: replication information not available, can&#x27;t generate the RDB file right now. Try later.&quot;</span>);</span><br><span class="line">     retval = C_ERR;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If we succeeded to start a BGSAVE with disk target, let&#x27;s remember</span></span><br><span class="line"><span class="comment">  * this fact, so that we can later delete the file if needed. Note</span></span><br><span class="line"><span class="comment">  * that we don&#x27;t set the flag to 1 if the feature is disabled, otherwise</span></span><br><span class="line"><span class="comment">  * it would never be cleared: the file is not deleted. This way if</span></span><br><span class="line"><span class="comment">  * the user enables it later with CONFIG SET, we are fine. */</span></span><br><span class="line"> <span class="keyword">if</span> (retval == C_OK &amp;&amp; !socket_target &amp;&amp; server.rdb_del_sync_files)</span><br><span class="line">     RDBGeneratedByReplication = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If we failed to BGSAVE, remove the slaves waiting for a full</span></span><br><span class="line"><span class="comment">  * resynchronization from the list of slaves, inform them with</span></span><br><span class="line"><span class="comment">  * an error about what happened, close the connection ASAP. */</span></span><br><span class="line"> <span class="keyword">if</span> (retval == C_ERR) &#123;</span><br><span class="line">     serverLog(LL_WARNING,<span class="string">&quot;BGSAVE for replication failed&quot;</span>);</span><br><span class="line">     listRewind(server.slaves,&amp;li);</span><br><span class="line">     <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">         client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">             slave-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">             slave-&gt;flags &amp;= ~CLIENT_SLAVE;</span><br><span class="line">             listDelNode(server.slaves,ln);</span><br><span class="line">             addReplyError(slave,</span><br><span class="line">                 <span class="string">&quot;BGSAVE failed, replication can&#x27;t continue&quot;</span>);</span><br><span class="line">             slave-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> retval;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If the target is socket, rdbSaveToSlavesSockets() already setup</span></span><br><span class="line"><span class="comment">  * the slaves for a full resync. Otherwise for disk target do it now.*/</span></span><br><span class="line"> <span class="keyword">if</span> (!socket_target) &#123;</span><br><span class="line">     listRewind(server.slaves,&amp;li);</span><br><span class="line">     <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">         client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                 replicationSetupSlaveForFullResync(slave,</span><br><span class="line">                         getPsyncInitialOffset());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Flush the script cache, since we need that slave differences are</span></span><br><span class="line"><span class="comment">  * accumulated without requiring slaves to match our cached scripts. */</span></span><br><span class="line"> <span class="keyword">if</span> (retval == C_OK) replicationScriptCacheFlush();</span><br><span class="line"> <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="rdb-数据的生成与发送"><a href="#rdb-数据的生成与发送" class="headerlink" title="rdb 数据的生成与发送"></a>rdb 数据的生成与发送</h3><h4 id="直接通过-socket-发送-rdb-数据"><a href="#直接通过-socket-发送-rdb-数据" class="headerlink" title="直接通过 socket 发送 rdb 数据"></a>直接通过 socket 发送 rdb 数据</h4><ol>
<li><p><code>rdb.c#rdbSaveToSlavesSockets()</code> 函数<font style=background-color:#f8f840>处理可以直接通过 socket 传输 rdb 数据的场景</font>，其重要步骤如下：</p>
<blockquote>
<ol>
<li>创建 pipe 管道，将读写端分别绑定到 <code>server.rdb_pipe_read</code> 和 <code>server.rdb_pipe_write</code>，并且将主节点的从节点列表中在 <code>SLAVE_STATE_WAIT_BGSAVE_START</code> 状态的从节点挑出来，调用<code>replicationSetupSlaveForFullResync()</code> 函数通知其将进行全量复制</li>
<li>调用 <code>redisFork()</code> 函数创建子进程，这里分两种情况，rdb 数据格式为 <font style=background-color:#f8f840>$EOF:<font color=green>40字节的随机字符串</font>\r\n<font color=red>文件流内容</font><font color=green>40字节的随机字符串</font></font><ol>
<li>如果现在就是在子进程中，<code>rioInitWithFd()</code> 函数将父进程管道写端<code>server.rdb_pipe_write</code> 与文件句柄 rdb 绑定，调用<code>rdbSaveRioWithEOFMark()</code>函数进行 rdb 数据的生成并将其写入管道，之后调用<code>sendChildCOWInfo()</code> 函数将生成 rdb 数据期间 <code>CopyOnWrite</code> 使用的内存相关数据传输到父进程中</li>
<li>如果现在在父进程中，其创建子进程没有出错，则通过 <code>aeCreateFileEvent()</code> 函数注册 <code>rdbPipeReadHandler()</code>函数处理管道读端 <code>server.rdb_pipe_read</code> 读取到的数据</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveToSlavesSockets</span><span class="params">(rdbSaveInfo *rsi)</span> &#123;</span><br><span class="line"> listNode *ln;</span><br><span class="line"> listIter li;</span><br><span class="line"> <span class="type">pid_t</span> childpid;</span><br><span class="line"> <span class="type">int</span> pipefds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Even if the previous fork child exited, don&#x27;t start a new one until we</span></span><br><span class="line"><span class="comment">  * drained the pipe. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.rdb_pipe_conns) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Before to fork, create a pipe that is used to transfer the rdb bytes to</span></span><br><span class="line"><span class="comment">  * the parent, we can&#x27;t let it write directly to the sockets, since in case</span></span><br><span class="line"><span class="comment">  * of TLS we must let the parent handle a continuous TLS state when the</span></span><br><span class="line"><span class="comment">  * child terminates and parent takes over. */</span></span><br><span class="line"> <span class="keyword">if</span> (pipe(pipefds) == <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"> server.rdb_pipe_read = pipefds[<span class="number">0</span>];</span><br><span class="line"> server.rdb_pipe_write = pipefds[<span class="number">1</span>];</span><br><span class="line"> anetNonBlock(<span class="literal">NULL</span>, server.rdb_pipe_read);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Collect the connections of the replicas we want to transfer</span></span><br><span class="line"><span class="comment">  * the RDB to, which are i WAIT_BGSAVE_START state. */</span></span><br><span class="line"> server.rdb_pipe_conns = zmalloc(<span class="keyword">sizeof</span>(connection *)*listLength(server.slaves));</span><br><span class="line"> server.rdb_pipe_numconns = <span class="number">0</span>;</span><br><span class="line"> server.rdb_pipe_numconns_writing = <span class="number">0</span>;</span><br><span class="line"> listRewind(server.slaves,&amp;li);</span><br><span class="line"> <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">     client *slave = ln-&gt;value;</span><br><span class="line">     <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">         server.rdb_pipe_conns[server.rdb_pipe_numconns++] = slave-&gt;conn;</span><br><span class="line">         replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create the child process. */</span></span><br><span class="line"> openChildInfoPipe();</span><br><span class="line"> <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">/* Child */</span></span><br><span class="line">     <span class="type">int</span> retval;</span><br><span class="line">     rio rdb;</span><br><span class="line"></span><br><span class="line">     rioInitWithFd(&amp;rdb,server.rdb_pipe_write);</span><br><span class="line"></span><br><span class="line">     redisSetProcTitle(<span class="string">&quot;redis-rdb-to-slaves&quot;</span>);</span><br><span class="line">     redisSetCpuAffinity(server.bgsave_cpulist);</span><br><span class="line"></span><br><span class="line">     retval = rdbSaveRioWithEOFMark(&amp;rdb,<span class="literal">NULL</span>,rsi);</span><br><span class="line">     <span class="keyword">if</span> (retval == C_OK &amp;&amp; rioFlush(&amp;rdb) == <span class="number">0</span>)</span><br><span class="line">         retval = C_ERR;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">         sendChildCOWInfo(CHILD_INFO_TYPE_RDB, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     rioFreeFd(&amp;rdb);</span><br><span class="line">     close(server.rdb_pipe_write); <span class="comment">/* wake up the reader, tell it we&#x27;re done. */</span></span><br><span class="line">     exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/* Parent */</span></span><br><span class="line">     <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">             strerror(errno));</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Undo the state change. The caller will perform cleanup on</span></span><br><span class="line"><span class="comment">          * all the slaves in BGSAVE_START state, but an early call to</span></span><br><span class="line"><span class="comment">          * replicationSetupSlaveForFullResync() turned it into BGSAVE_END */</span></span><br><span class="line">         listRewind(server.slaves,&amp;li);</span><br><span class="line">         <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">             client *slave = ln-&gt;value;</span><br><span class="line">             <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) &#123;</span><br><span class="line">                 slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         close(server.rdb_pipe_write);</span><br><span class="line">         close(server.rdb_pipe_read);</span><br><span class="line">         zfree(server.rdb_pipe_conns);</span><br><span class="line">         server.rdb_pipe_conns = <span class="literal">NULL</span>;</span><br><span class="line">         server.rdb_pipe_numconns = <span class="number">0</span>;</span><br><span class="line">         server.rdb_pipe_numconns_writing = <span class="number">0</span>;</span><br><span class="line">         closeChildInfoPipe();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         serverLog(LL_NOTICE,<span class="string">&quot;Background RDB transfer started by pid %d&quot;</span>,</span><br><span class="line">             childpid);</span><br><span class="line">         server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">         server.rdb_child_pid = childpid;</span><br><span class="line">         server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;</span><br><span class="line">         close(server.rdb_pipe_write); <span class="comment">/* close write in parent so that it can detect the close on the child. */</span></span><br><span class="line">         <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,<span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">             serverPanic(<span class="string">&quot;Unrecoverable error creating server.rdb_pipe_read file event.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (childpid == <span class="number">-1</span>) ? C_ERR : C_OK;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> C_OK; <span class="comment">/* Unreached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replication.c#rdbPipeReadHandler()</code> 函数会读取子进程生成的 rdb 数据，并为从节点连接设置写数据的回调。该函数的处理流程如下：</p>
<blockquote>
<ol>
<li>首先处理管道读端读取数据出错和数据读取已经结束的情况</li>
<li>遍历等待 rdb 数据的从节点列表， 将 rdb 数据读取到 <code>server.rdb_pipe_buff</code> 中，调用 <code>connSetWriteHandler()</code> 函数在从节点连接上设置写处理函数 <code>rdbPipeWriteHandler()</code>，在其可写时发送 rdb 数据</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rdbPipeReadHandler</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">void</span> *clientData, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line"> UNUSED(mask);</span><br><span class="line"> UNUSED(clientData);</span><br><span class="line"> UNUSED(eventLoop);</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="keyword">if</span> (!server.rdb_pipe_buff)</span><br><span class="line">     server.rdb_pipe_buff = zmalloc(PROTO_IOBUF_LEN);</span><br><span class="line"> serverAssert(server.rdb_pipe_numconns_writing==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     server.rdb_pipe_bufflen = read(fd, server.rdb_pipe_buff, PROTO_IOBUF_LEN);</span><br><span class="line">     <span class="keyword">if</span> (server.rdb_pipe_bufflen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;Diskless rdb transfer, read error sending DB to replicas: %s&quot;</span>, strerror(errno));</span><br><span class="line">         <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; server.rdb_pipe_numconns; i++) &#123;</span><br><span class="line">             connection *conn = server.rdb_pipe_conns[i];</span><br><span class="line">             <span class="keyword">if</span> (!conn)</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             client *slave = connGetPrivateData(conn);</span><br><span class="line">             freeClient(slave);</span><br><span class="line">             server.rdb_pipe_conns[i] = <span class="literal">NULL</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         killRDBChild();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (server.rdb_pipe_bufflen == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/* EOF - write end was closed. */</span></span><br><span class="line">         <span class="type">int</span> stillUp = <span class="number">0</span>;</span><br><span class="line">         aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);</span><br><span class="line">         <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; server.rdb_pipe_numconns; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             connection *conn = server.rdb_pipe_conns[i];</span><br><span class="line">             <span class="keyword">if</span> (!conn)</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             stillUp++;</span><br><span class="line">         &#125;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;Diskless rdb transfer, done reading from pipe, %d replicas still up.&quot;</span>, stillUp);</span><br><span class="line">         RdbPipeCleanup();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> stillAlive = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; server.rdb_pipe_numconns; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> nwritten;</span><br><span class="line">         connection *conn = server.rdb_pipe_conns[i];</span><br><span class="line">         <span class="keyword">if</span> (!conn)</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         client *slave = connGetPrivateData(conn);</span><br><span class="line">         <span class="keyword">if</span> ((nwritten = connWrite(conn, server.rdb_pipe_buff, server.rdb_pipe_bufflen)) == <span class="number">-1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">                 serverLog(LL_WARNING,<span class="string">&quot;Diskless rdb transfer, write error sending DB to replica: %s&quot;</span>,</span><br><span class="line">                     connGetLastError(conn));</span><br><span class="line">                 freeClient(slave);</span><br><span class="line">                 server.rdb_pipe_conns[i] = <span class="literal">NULL</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/* An error and still in connected state, is equivalent to EAGAIN */</span></span><br><span class="line">             slave-&gt;repldboff = <span class="number">0</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             slave-&gt;repldboff = nwritten;</span><br><span class="line">             server.stat_net_output_bytes += nwritten;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* If we were unable to write all the data to one of the replicas,</span></span><br><span class="line"><span class="comment">          * setup write handler (and disable pipe read handler, below) */</span></span><br><span class="line">         <span class="keyword">if</span> (nwritten != server.rdb_pipe_bufflen) &#123;</span><br><span class="line">             server.rdb_pipe_numconns_writing++;</span><br><span class="line">             connSetWriteHandler(conn, rdbPipeWriteHandler);</span><br><span class="line">         &#125;</span><br><span class="line">         stillAlive++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (stillAlive == <span class="number">0</span>) &#123;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;Diskless rdb transfer, last replica dropped, killing fork child.&quot;</span>);</span><br><span class="line">         killRDBChild();</span><br><span class="line">         RdbPipeCleanup();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*  Remove the pipe read handler if at least one write handler was set. */</span></span><br><span class="line">     <span class="keyword">if</span> (server.rdb_pipe_numconns_writing || stillAlive == <span class="number">0</span>) &#123;</span><br><span class="line">         aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replication.c#rdbPipeWriteHandler()</code> 函数负责将  <code>server.rdb_pipe_buff</code> 中读取的 rdb 数据发送给从节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rdbPipeWriteHandler</span><span class="params">(<span class="keyword">struct</span> connection *conn)</span> &#123;</span><br><span class="line"> serverAssert(server.rdb_pipe_bufflen&gt;<span class="number">0</span>);</span><br><span class="line"> client *slave = connGetPrivateData(conn);</span><br><span class="line"> <span class="type">int</span> nwritten;</span><br><span class="line"> <span class="keyword">if</span> ((nwritten = connWrite(conn, server.rdb_pipe_buff + slave-&gt;repldboff,</span><br><span class="line">                           server.rdb_pipe_bufflen - slave-&gt;repldboff)) == <span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED)</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">/* equivalent to EAGAIN */</span></span><br><span class="line">     serverLog(LL_WARNING,<span class="string">&quot;Write error sending DB to replica: %s&quot;</span>,</span><br><span class="line">         connGetLastError(conn));</span><br><span class="line">     freeClient(slave);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     slave-&gt;repldboff += nwritten;</span><br><span class="line">     server.stat_net_output_bytes += nwritten;</span><br><span class="line">     <span class="keyword">if</span> (slave-&gt;repldboff &lt; server.rdb_pipe_bufflen)</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">/* more data to write.. */</span></span><br><span class="line"> &#125;</span><br><span class="line"> rdbPipeWriteHandlerConnRemoved(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="发送-rdb-文件"><a href="#发送-rdb-文件" class="headerlink" title="发送 rdb 文件"></a>发送 rdb 文件</h4><ol>
<li><p><code>rdb.c#rdbSaveBackground()</code> 函数<font style=background-color:#f8f840>负责处理必须传输 rdb 文件的场景</font>，其主要处理步骤如下：</p>
<blockquote>
<ol>
<li><code>redisFork()</code> 创建子进程，与上文类似，如果现在在子进程中，则调用 <code>rdbSave()</code>函数保存 rdb 数据，完成后通过 <code>sendChildCOWInfo()</code> 函数将生成 rdb 数据期间 <code>CopyOnWrite</code> 使用的内存相关数据发送给父进程</li>
<li>如果现在在父进程中，则只需要更新 server 相关变量即可，比较重要的是 <code>server.rdb_child_pid</code> 变量</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> &#123;</span><br><span class="line"> <span class="type">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line"> server.dirty_before_bgsave = server.dirty;</span><br><span class="line"> server.lastbgsave_try = time(<span class="literal">NULL</span>);</span><br><span class="line"> openChildInfoPipe();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Child */</span></span><br><span class="line">     redisSetProcTitle(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">     redisSetCpuAffinity(server.bgsave_cpulist);</span><br><span class="line">     retval = rdbSave(filename,rsi);</span><br><span class="line">     <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">         sendChildCOWInfo(CHILD_INFO_TYPE_RDB, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/* Parent */</span></span><br><span class="line">     <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">         closeChildInfoPipe();</span><br><span class="line">         server.lastbgsave_status = C_ERR;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">             strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> C_ERR;</span><br><span class="line">     &#125;</span><br><span class="line">     serverLog(LL_NOTICE,<span class="string">&quot;Background saving started by pid %d&quot;</span>,childpid);</span><br><span class="line">     server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">     server.rdb_child_pid = childpid;</span><br><span class="line">     server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">     <span class="keyword">return</span> C_OK;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>子进程保存 rdb 数据的函数为 <code>rdb.c#rdbSave()</code> ，其核心为调用 <code>rdbSaveRio()</code> 函数生成 rdb 数据，之后调用 <code>fflush()</code> 函数将其写入临时文件，写入完成后将临时文件重命名替换旧的 RDB 文件，此处不作具体分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rdbSave</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> &#123;</span><br><span class="line"> <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"> <span class="type">char</span> cwd[MAXPATHLEN]; <span class="comment">/* Current working dir path for error messages. */</span></span><br><span class="line"> FILE *fp;</span><br><span class="line"> rio rdb;</span><br><span class="line"> <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"> fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">     <span class="type">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">     serverLog(LL_WARNING,</span><br><span class="line">         <span class="string">&quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span></span><br><span class="line">         <span class="string">&quot;for saving: %s&quot;</span>,</span><br><span class="line">         filename,</span><br><span class="line">         cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">         strerror(errno));</span><br><span class="line">     <span class="keyword">return</span> C_ERR;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> rioInitWithFile(&amp;rdb,fp);</span><br><span class="line"> startSaving(RDBFLAGS_NONE);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">     rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">     errno = error;</span><br><span class="line">     <span class="keyword">goto</span> werr;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span></span><br><span class="line"> <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"> <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"> <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">  * if the generate DB file is ok. */</span></span><br><span class="line"> <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="type">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">     serverLog(LL_WARNING,</span><br><span class="line">         <span class="string">&quot;Error moving temp DB file %s on the final &quot;</span></span><br><span class="line">         <span class="string">&quot;destination %s (in server root dir %s): %s&quot;</span>,</span><br><span class="line">         tmpfile,</span><br><span class="line">         filename,</span><br><span class="line">         cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">         strerror(errno));</span><br><span class="line">     unlink(tmpfile);</span><br><span class="line">     stopSaving(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> C_ERR;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> serverLog(LL_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>);</span><br><span class="line"> server.dirty = <span class="number">0</span>;</span><br><span class="line"> server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line"> server.lastbgsave_status = C_OK;</span><br><span class="line"> stopSaving(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line"> serverLog(LL_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line"> fclose(fp);</span><br><span class="line"> unlink(tmpfile);</span><br><span class="line"> stopSaving(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>在子进程保存 rdb 数据时，redis 的定时任务 <code>server.c#serverCron()</code> 会周期性地去检查这个动作是否完成，关键函数为 <code>checkChildrenDone()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Check if a background saving or AOF rewrite in progress terminated. */</span></span><br><span class="line"> <span class="keyword">if</span> (hasActiveChildProcess() || ldbPendingChildren())</span><br><span class="line"> &#123;</span><br><span class="line">     checkChildrenDone();</span><br><span class="line"> &#125; </span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>server.c#checkChildrenDone()</code>函数的逻辑较为简单，可以归纳为以下几步：</p>
<blockquote>
<ol>
<li><code>wait3()</code> 函数接收子进程结束的信号，根据子进程的 pid 进行不同的处理</li>
<li>对于 <code>server.rdb_child_pid</code> 子进程，其处理函数为 <code>backgroundSaveDoneHandler()</code></li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">checkChildrenDone</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="type">int</span> statloc;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If we have a diskless rdb child (note that we support only one concurrent</span></span><br><span class="line"><span class="comment">  * child), we want to avoid collecting it&#x27;s exit status and acting on it</span></span><br><span class="line"><span class="comment">  * as long as we didn&#x27;t finish to drain the pipe, since then we&#x27;re at risk</span></span><br><span class="line"><span class="comment">  * of starting a new fork and a new pipe before we&#x27;re done with the previous</span></span><br><span class="line"><span class="comment">  * one. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp; server.rdb_pipe_conns)</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="type">int</span> exitcode = WEXITSTATUS(statloc);</span><br><span class="line">     <span class="type">int</span> bysignal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* sigKillChildHandler catches the signal and calls exit(), but we</span></span><br><span class="line"><span class="comment">      * must make sure not to flag lastbgsave_status, etc incorrectly.</span></span><br><span class="line"><span class="comment">      * We could directly terminate the child process via SIGUSR1</span></span><br><span class="line"><span class="comment">      * without handling it, but in this case Valgrind will log an</span></span><br><span class="line"><span class="comment">      * annoying error. */</span></span><br><span class="line">     <span class="keyword">if</span> (exitcode == SERVER_CHILD_NOERROR_RETVAL) &#123;</span><br><span class="line">         bysignal = SIGUSR1;</span><br><span class="line">         exitcode = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;wait3() returned an error: %s. &quot;</span></span><br><span class="line">             <span class="string">&quot;rdb_child_pid = %d, aof_child_pid = %d, module_child_pid = %d&quot;</span>,</span><br><span class="line">             strerror(errno),</span><br><span class="line">             (<span class="type">int</span>) server.rdb_child_pid,</span><br><span class="line">             (<span class="type">int</span>) server.aof_child_pid,</span><br><span class="line">             (<span class="type">int</span>) server.module_child_pid);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.rdb_child_pid) &#123;</span><br><span class="line">         backgroundSaveDoneHandler(exitcode,bysignal);</span><br><span class="line">         <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) receiveChildInfo();</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.aof_child_pid) &#123;</span><br><span class="line">         backgroundRewriteDoneHandler(exitcode,bysignal);</span><br><span class="line">         <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) receiveChildInfo();</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.module_child_pid) &#123;</span><br><span class="line">         ModuleForkDoneHandler(exitcode,bysignal);</span><br><span class="line">         <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) receiveChildInfo();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (!ldbRemoveChild(pid)) &#123;</span><br><span class="line">             serverLog(LL_WARNING,</span><br><span class="line">                 <span class="string">&quot;Warning, detected child with unmatched pid: %ld&quot;</span>,</span><br><span class="line">                 (<span class="type">long</span>)pid);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     updateDictResizePolicy();</span><br><span class="line">     closeChildInfoPipe();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rdb.c#backgroundSaveDoneHandler()</code> 函数其实只是个转发，其核心是根据 rdb 数据的传输形式调用不同的处理函数，此处为调用 <code>backgroundSaveDoneHandlerDisk()</code> 函数</p>
<blockquote>
<p><code>backgroundSaveDoneHandlerDisk()</code> 函数主要更新了一些变量，最重要的是调用 <code>updateSlavesWaitingBgsave()</code> 函数启动 rdb 文件的传输</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backgroundSaveDoneHandler</span><span class="params">(<span class="type">int</span> exitcode, <span class="type">int</span> bysignal)</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span>(server.rdb_child_type) &#123;</span><br><span class="line"> <span class="keyword">case</span> RDB_CHILD_TYPE_DISK:</span><br><span class="line">     backgroundSaveDoneHandlerDisk(exitcode,bysignal);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> RDB_CHILD_TYPE_SOCKET:</span><br><span class="line">     backgroundSaveDoneHandlerSocket(exitcode,bysignal);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">     serverPanic(<span class="string">&quot;Unknown RDB child type.&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backgroundSaveDoneHandlerDisk</span><span class="params">(<span class="type">int</span> exitcode, <span class="type">int</span> bysignal)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) &#123;</span><br><span class="line">     serverLog(LL_NOTICE,</span><br><span class="line">         <span class="string">&quot;Background saving terminated with success&quot;</span>);</span><br><span class="line">     server.dirty = server.dirty - server.dirty_before_bgsave;</span><br><span class="line">     server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">     server.lastbgsave_status = C_OK;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode != <span class="number">0</span>) &#123;</span><br><span class="line">     serverLog(LL_WARNING, <span class="string">&quot;Background saving error&quot;</span>);</span><br><span class="line">     server.lastbgsave_status = C_ERR;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="type">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">     serverLog(LL_WARNING,</span><br><span class="line">         <span class="string">&quot;Background saving terminated by signal %d&quot;</span>, bysignal);</span><br><span class="line">     latencyStartMonitor(latency);</span><br><span class="line">     rdbRemoveTempFile(server.rdb_child_pid);</span><br><span class="line">     latencyEndMonitor(latency);</span><br><span class="line">     latencyAddSampleIfNeeded(<span class="string">&quot;rdb-unlink-temp-file&quot;</span>,latency);</span><br><span class="line">     <span class="comment">/* SIGUSR1 is whitelisted, so we have a way to kill a child without</span></span><br><span class="line"><span class="comment">      * tirggering an error condition. */</span></span><br><span class="line">     <span class="keyword">if</span> (bysignal != SIGUSR1)</span><br><span class="line">         server.lastbgsave_status = C_ERR;</span><br><span class="line"> &#125;</span><br><span class="line"> server.rdb_child_pid = <span class="number">-1</span>;</span><br><span class="line"> server.rdb_child_type = RDB_CHILD_TYPE_NONE;</span><br><span class="line"> server.rdb_save_time_last = time(<span class="literal">NULL</span>)-server.rdb_save_time_start;</span><br><span class="line"> server.rdb_save_time_start = <span class="number">-1</span>;</span><br><span class="line"> <span class="comment">/* Possibly there are slaves waiting for a BGSAVE in order to be served</span></span><br><span class="line"><span class="comment">  * (the first stage of SYNC is a bulk transfer of dump.rdb) */</span></span><br><span class="line"> updateSlavesWaitingBgsave((!bysignal &amp;&amp; exitcode == <span class="number">0</span>) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replication.c#updateSlavesWaitingBgsave()</code> 函数比较简单，其核心在于<font style=background-color:#f8f840>将 rdb文件读取出来，存入所有等待 rdb 文件的从节点客户端<code>slave-&gt;repldbfd</code>变量，并为其连接设置写处理函数 <code>sendBulkToSlave()</code>，从而完成 rdb 文件传输</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateSlavesWaitingBgsave</span><span class="params">(<span class="type">int</span> bgsaveerr, <span class="type">int</span> type)</span> &#123;</span><br><span class="line"> listNode *ln;</span><br><span class="line"> <span class="type">int</span> startbgsave = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> mincapa = <span class="number">-1</span>;</span><br><span class="line"> listIter li;</span><br><span class="line"></span><br><span class="line"> listRewind(server.slaves,&amp;li);</span><br><span class="line"> <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">     client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">         startbgsave = <span class="number">1</span>;</span><br><span class="line">         mincapa = (mincapa == <span class="number">-1</span>) ? slave-&gt;slave_capa :</span><br><span class="line">                                     (mincapa &amp; slave-&gt;slave_capa);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) &#123;</span><br><span class="line">         <span class="keyword">struct</span> redis_stat buf;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (bgsaveerr != C_OK) &#123;</span><br><span class="line">             freeClient(slave);</span><br><span class="line">             serverLog(LL_WARNING,<span class="string">&quot;SYNC failed. BGSAVE child returned an error&quot;</span>);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* If this was an RDB on disk save, we have to prepare to send</span></span><br><span class="line"><span class="comment">          * the RDB from disk to the slave socket. Otherwise if this was</span></span><br><span class="line"><span class="comment">          * already an RDB -&gt; Slaves socket transfer, used in the case of</span></span><br><span class="line"><span class="comment">          * diskless replication, our work is trivial, we can just put</span></span><br><span class="line"><span class="comment">          * the slave online. */</span></span><br><span class="line">         <span class="keyword">if</span> (type == RDB_CHILD_TYPE_SOCKET) &#123;</span><br><span class="line">             serverLog(LL_NOTICE,</span><br><span class="line">                 <span class="string">&quot;Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming&quot;</span>,</span><br><span class="line">                     replicationGetSlaveName(slave));</span><br><span class="line">             <span class="comment">/* Note: we wait for a REPLCONF ACK message from the replica in</span></span><br><span class="line"><span class="comment">              * order to really put it online (install the write handler</span></span><br><span class="line"><span class="comment">              * so that the accumulated data can be transferred). However</span></span><br><span class="line"><span class="comment">              * we change the replication state ASAP, since our slave</span></span><br><span class="line"><span class="comment">              * is technically online now.</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * So things work like that:</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * 1. We end trasnferring the RDB file via socket.</span></span><br><span class="line"><span class="comment">              * 2. The replica is put ONLINE but the write handler</span></span><br><span class="line"><span class="comment">              *    is not installed.</span></span><br><span class="line"><span class="comment">              * 3. The replica however goes really online, and pings us</span></span><br><span class="line"><span class="comment">              *    back via REPLCONF ACK commands.</span></span><br><span class="line"><span class="comment">              * 4. Now we finally install the write handler, and send</span></span><br><span class="line"><span class="comment">              *    the buffers accumulated so far to the replica.</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * But why we do that? Because the replica, when we stream</span></span><br><span class="line"><span class="comment">              * the RDB directly via the socket, must detect the RDB</span></span><br><span class="line"><span class="comment">              * EOF (end of file), that is a special random string at the</span></span><br><span class="line"><span class="comment">              * end of the RDB (for streamed RDBs we don&#x27;t know the length</span></span><br><span class="line"><span class="comment">              * in advance). Detecting such final EOF string is much</span></span><br><span class="line"><span class="comment">              * simpler and less CPU intensive if no more data is sent</span></span><br><span class="line"><span class="comment">              * after such final EOF. So we don&#x27;t want to glue the end of</span></span><br><span class="line"><span class="comment">              * the RDB trasfer with the start of the other replication</span></span><br><span class="line"><span class="comment">              * data. */</span></span><br><span class="line">             slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">             slave-&gt;repl_put_online_on_ack = <span class="number">1</span>;</span><br><span class="line">             slave-&gt;repl_ack_time = server.unixtime; <span class="comment">/* Timeout otherwise. */</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> ((slave-&gt;repldbfd = open(server.rdb_filename,O_RDONLY)) == <span class="number">-1</span> ||</span><br><span class="line">                 redis_fstat(slave-&gt;repldbfd,&amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">                 freeClient(slave);</span><br><span class="line">                 serverLog(LL_WARNING,<span class="string">&quot;SYNC failed. Can&#x27;t open/stat DB after BGSAVE: %s&quot;</span>, strerror(errno));</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             slave-&gt;repldboff = <span class="number">0</span>;</span><br><span class="line">             slave-&gt;repldbsize = buf.st_size;</span><br><span class="line">             slave-&gt;replstate = SLAVE_STATE_SEND_BULK;</span><br><span class="line">             slave-&gt;replpreamble = sdscatprintf(sdsempty(),<span class="string">&quot;$%lld\r\n&quot;</span>,</span><br><span class="line">                 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) slave-&gt;repldbsize);</span><br><span class="line"></span><br><span class="line">             connSetWriteHandler(slave-&gt;conn,<span class="literal">NULL</span>);</span><br><span class="line">             <span class="keyword">if</span> (connSetWriteHandler(slave-&gt;conn,sendBulkToSlave) == C_ERR) &#123;</span><br><span class="line">                 freeClient(slave);</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (startbgsave) startBgsaveForReplication(mincapa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replication.c#sendBulkToSlave()</code> 函数的逻辑很简单，可以总结为以下几步：</p>
<blockquote>
<ol>
<li>将从节点客户端 <code>slave-&gt;repldbfd</code> 存储的 rdb 文件数据写给从节点</li>
<li>调用 <code>putSlaveOnline()</code> 函数设置从节点状态为 <code>SLAVE_STATE_ONLINE</code></li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sendBulkToSlave</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line"> client *slave = connGetPrivateData(conn);</span><br><span class="line"> <span class="type">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line"> <span class="type">ssize_t</span> nwritten, buflen;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Before sending the RDB file, we send the preamble as configured by the</span></span><br><span class="line"><span class="comment">  * replication process. Currently the preamble is just the bulk count of</span></span><br><span class="line"><span class="comment">  * the file in the form &quot;$&lt;length&gt;\r\n&quot;. */</span></span><br><span class="line"> <span class="keyword">if</span> (slave-&gt;replpreamble) &#123;</span><br><span class="line">     nwritten = connWrite(conn,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));</span><br><span class="line">     <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">         serverLog(LL_VERBOSE,</span><br><span class="line">             <span class="string">&quot;Write error sending RDB preamble to replica: %s&quot;</span>,</span><br><span class="line">             connGetLastError(conn));</span><br><span class="line">         freeClient(slave);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     server.stat_net_output_bytes += nwritten;</span><br><span class="line">     sdsrange(slave-&gt;replpreamble,nwritten,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">if</span> (sdslen(slave-&gt;replpreamble) == <span class="number">0</span>) &#123;</span><br><span class="line">         sdsfree(slave-&gt;replpreamble);</span><br><span class="line">         slave-&gt;replpreamble = <span class="literal">NULL</span>;</span><br><span class="line">         <span class="comment">/* fall through sending data. */</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If the preamble was already transferred, send the RDB bulk data. */</span></span><br><span class="line"> lseek(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);</span><br><span class="line"> buflen = read(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN);</span><br><span class="line"> <span class="keyword">if</span> (buflen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     serverLog(LL_WARNING,<span class="string">&quot;Read error sending DB to replica: %s&quot;</span>,</span><br><span class="line">         (buflen == <span class="number">0</span>) ? <span class="string">&quot;premature EOF&quot;</span> : strerror(errno));</span><br><span class="line">     freeClient(slave);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> ((nwritten = connWrite(conn,buf,buflen)) == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">         serverLog(LL_WARNING,<span class="string">&quot;Write error sending DB to replica: %s&quot;</span>,</span><br><span class="line">             connGetLastError(conn));</span><br><span class="line">         freeClient(slave);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> slave-&gt;repldboff += nwritten;</span><br><span class="line"> server.stat_net_output_bytes += nwritten;</span><br><span class="line"> <span class="keyword">if</span> (slave-&gt;repldboff == slave-&gt;repldbsize) &#123;</span><br><span class="line">     close(slave-&gt;repldbfd);</span><br><span class="line">     slave-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">     connSetWriteHandler(slave-&gt;conn,<span class="literal">NULL</span>);</span><br><span class="line">     putSlaveOnline(slave);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replication.c#putSlaveOnline()</code> 函数逻辑简单明了，主要做了以下两件事，至此 Master 节点主从同步结束</p>
<blockquote>
<ol>
<li>设置从节点同步状态 <code>slave-&gt;replstate</code> 为 <code>SLAVE_STATE_ONLINE</code></li>
<li>调用 <code>connSetWriteHandler()</code> 函数为从节点连接设置写函数 <code>sendReplyToClient()</code>，将主节点保存 rdb 期间执行过的操作命令同步到从节点</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">putSlaveOnline</span><span class="params">(client *slave)</span> &#123;</span><br><span class="line"> slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line"> slave-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line"> slave-&gt;repl_ack_time = server.unixtime; <span class="comment">/* Prevent false timeout. */</span></span><br><span class="line"> <span class="keyword">if</span> (connSetWriteHandler(slave-&gt;conn, sendReplyToClient) == C_ERR) &#123;</span><br><span class="line">     serverLog(LL_WARNING,<span class="string">&quot;Unable to register writable event for replica bulk transfer: %s&quot;</span>, strerror(errno));</span><br><span class="line">     freeClient(slave);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> refreshGoodSlavesCount();</span><br><span class="line"> <span class="comment">/* Fire the replica change modules event. */</span></span><br><span class="line"> moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,</span><br><span class="line">                       REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line"> serverLog(LL_NOTICE,<span class="string">&quot;Synchronization with replica %s succeeded&quot;</span>,</span><br><span class="line">     replicationGetSlaveName(slave));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yang00-74.github.io">nathan.yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yang00-74.github.io/2023/06/06/Redis-10/">https://yang00-74.github.io/2023/06/06/Redis-10/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yang00-74.github.io" target="_blank">谈谈1974</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/06/Redis-11/" title="Redis 6.0 源码阅读笔记(11)-主从复制 Slave 节点流程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 6.0 源码阅读笔记(11)-主从复制 Slave 节点流程分析</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/05/Redis-9/" title="Redis 6.0 源码阅读笔记(9)-数据淘汰原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis 6.0 源码阅读笔记(9)-数据淘汰原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/06/Redis-12/" title="Redis 6.0 源码阅读笔记(12)-Redis 集群建立流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Redis 6.0 源码阅读笔记(12)-Redis 集群建立流程</div></div></a></div><div><a href="/2023/06/06/Redis-cluster/" title="RedisCluster 集群实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">RedisCluster 集群实现原理</div></div></a></div><div><a href="/2023/06/06/Redis-11/" title="Redis 6.0 源码阅读笔记(11)-主从复制 Slave 节点流程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Redis 6.0 源码阅读笔记(11)-主从复制 Slave 节点流程分析</div></div></a></div><div><a href="/2023/06/06/Redis-13/" title="Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程</div></div></a></div><div><a href="/2023/06/02/Redis-3/" title="Redis 6.0 源码阅读笔记(3)-概述 Redis 重要数据结构及其 6 种数据类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">Redis 6.0 源码阅读笔记(3)-概述 Redis 重要数据结构及其 6 种数据类型</div></div></a></div><div><a href="/2023/06/02/Redis-4/" title="Redis 6.0 源码阅读笔记(4)-String 数据类型源码分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">Redis 6.0 源码阅读笔记(4)-String 数据类型源码分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">nathan.yang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yang00-74"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to nathan blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD-Master-%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">主从复制中 Master 节点的处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">处理流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#psync-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%A4%A7%E8%87%B4%E5%A4%84%E7%90%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">psync 命令的大致处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E5%8F%91%E9%80%81"><span class="toc-number">2.0.2.</span> <span class="toc-text">rdb 数据的生成与发送</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87-socket-%E5%8F%91%E9%80%81-rdb-%E6%95%B0%E6%8D%AE"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">直接通过 socket 发送 rdb 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81-rdb-%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">发送 rdb 文件</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/09/Java-dynamic-proxy/" title="Java 动态代理的底层原理">Java 动态代理的底层原理</a><time datetime="2023-06-09T03:32:15.000Z" title="发表于 2023-06-09 11:32:15">2023-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/09/Java-memory-high/" title="Java 服务内存占用过高的一次排查过程">Java 服务内存占用过高的一次排查过程</a><time datetime="2023-06-09T03:15:23.000Z" title="发表于 2023-06-09 11:15:23">2023-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/08/Redis-rdb/" title="Redis 持久化 RDB 详解">Redis 持久化 RDB 详解</a><time datetime="2023-06-08T08:23:11.000Z" title="发表于 2023-06-08 16:23:11">2023-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/08/Java-memory-leak/" title="Java 使用 VisualVM 排查内存泄露">Java 使用 VisualVM 排查内存泄露</a><time datetime="2023-06-08T01:42:10.000Z" title="发表于 2023-06-08 09:42:10">2023-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/06/Redis-13/" title="Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程">Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程</a><time datetime="2023-06-06T12:44:54.000Z" title="发表于 2023-06-06 20:44:54">2023-06-06</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By nathan.yang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="点,啥,呢" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>