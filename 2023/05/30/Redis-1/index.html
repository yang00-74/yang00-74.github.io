<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 6.0 源码阅读笔记(1)-Redis 服务端启动及命令执行 | 谈谈1974</title><meta name="author" content="nathan.yang"><meta name="copyright" content="nathan.yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文基于 Redis 6.0 版本 ，读者如有兴趣可以自行点击链接进入 github 下载源码。Redis 用 C语言编写，其源码中不乏几百行的方法，这会给习惯了面向对象编程的读者造成一定的阅读障碍，不过仔细看的话也是能看懂的。Redis 服务端启动及命令执行的大致流程如下图所示，下文将对流程进行代码分析  Redis 服务端启动流程Redis 服务端的启动也就是事件循环的建立过程，服务端启动">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 6.0 源码阅读笔记(1)-Redis 服务端启动及命令执行">
<meta property="og:url" content="https://yang00-74.github.io/2023/05/30/Redis-1/index.html">
<meta property="og:site_name" content="谈谈1974">
<meta property="og:description" content="前言本文基于 Redis 6.0 版本 ，读者如有兴趣可以自行点击链接进入 github 下载源码。Redis 用 C语言编写，其源码中不乏几百行的方法，这会给习惯了面向对象编程的读者造成一定的阅读障碍，不过仔细看的话也是能看懂的。Redis 服务端启动及命令执行的大致流程如下图所示，下文将对流程进行代码分析  Redis 服务端启动流程Redis 服务端的启动也就是事件循环的建立过程，服务端启动">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-30T08:57:00.000Z">
<meta property="article:modified_time" content="2023-06-05T06:06:00.590Z">
<meta property="article:author" content="nathan.yang">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/drogan.jpg"><link rel="canonical" href="https://yang00-74.github.io/2023/05/30/Redis-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 6.0 源码阅读笔记(1)-Redis 服务端启动及命令执行',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-05 14:06:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="谈谈1974"><span class="site-name">谈谈1974</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis 6.0 源码阅读笔记(1)-Redis 服务端启动及命令执行</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-30T08:57:00.000Z" title="发表于 2023-05-30 16:57:00">2023-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-05T06:06:00.590Z" title="更新于 2023-06-05 14:06:00">2023-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 6.0 源码阅读笔记(1)-Redis 服务端启动及命令执行"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文基于 <a target="_blank" rel="noopener" href="https://github.com/redis/redis">Redis 6.0 版本</a> ，读者如有兴趣可以自行点击链接进入 github 下载源码。Redis 用 <code>C语言</code>编写，其源码中不乏几百行的方法，这会给习惯了面向对象编程的读者造成一定的阅读障碍，不过仔细看的话也是能看懂的。Redis 服务端启动及命令执行的大致流程如下图所示，下文将对流程进行代码分析</p>
<p><img src="/../images/redis-1-1.png" alt="在这里插入图片描述"></p>
<h1 id="Redis-服务端启动流程"><a href="#Redis-服务端启动流程" class="headerlink" title="Redis 服务端启动流程"></a>Redis 服务端启动流程</h1><p>Redis 服务端的启动也就是事件循环的建立过程，服务端启动的入口为 <code>server.c#main()</code> 函数</p>
<ol>
<li><p><code>server.c#main()</code> 函数很长，此处只截取几个重要的方法调用来分析</p>
<blockquote>
<ol>
<li>initServerConfig()<br>初始化 server 端的各项配置，本文重点关注其中的 populateCommandTable() 函数，这个函数将 redis 各个命令对应的 redisCommand 结构体存入了 server 的数据结构内</li>
<li>loadServerConfig()<br>载入配置文件，初始化服务端相关配置，比如在这一步会配置 redis 的监听端口</li>
<li>initServer()<br>主要创建事件循环实例，设置服务端处理 socket 事件的处理函数及处理定时事件的处理函数</li>
<li>aeMain()<br>启动事件循环处理线程，开始接受客户端连接并处理客户端命令</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> initServerConfig();</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> loadServerConfig(configfile,options);</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> initServer();</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> aeMain(server.el);</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>server.c#initServerConfig()</code> 函数中会初始化服务端的各项配置，其中本文比较关注的是 <code>populateCommandTable()</code> 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">initServerConfig</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> server.hz = CONFIG_DEFAULT_HZ; <span class="comment">/* Initialize it ASAP, even if it may get</span></span><br><span class="line"><span class="comment">                                   updated later after loading the config.</span></span><br><span class="line"><span class="comment">                                   This value may be used before the server</span></span><br><span class="line"><span class="comment">                                   is initialized. */</span></span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> server.commands = dictCreate(&amp;commandTableDictType,NULL);</span><br><span class="line"> server.orig_commands = dictCreate(&amp;commandTableDictType,NULL);</span><br><span class="line"> populateCommandTable();</span><br><span class="line"> server.delCommand = lookupCommandByCString(<span class="string">&quot;del&quot;</span>);</span><br><span class="line"> server.multiCommand = lookupCommandByCString(<span class="string">&quot;multi&quot;</span>);</span><br><span class="line"> server.lpushCommand = lookupCommandByCString(<span class="string">&quot;lpush&quot;</span>);</span><br><span class="line"> server.lpopCommand = lookupCommandByCString(<span class="string">&quot;lpop&quot;</span>);</span><br><span class="line"> server.rpopCommand = lookupCommandByCString(<span class="string">&quot;rpop&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>server.c#populateCommandTable()</code> 函数会将源码中硬编码的命令列表解析存储到 <code>server.commands</code> 中。<br>需注意，<code>redisCommandTable</code> 是一个硬编码的数组，其存储的结构如下：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand redisCommandTable[] = &#123;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;get&quot;</span>,getCommand,<span class="number">2</span>,</span><br><span class="line"> <span class="string">&quot;read-only fast @string&quot;</span>,</span><br><span class="line"> <span class="number">0</span>,NULL,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>redisCommand</code> 是一条命令的存储结构，其中 <code>name</code> 属性为命令名称，<code>proc</code> 为函数的指针，通过该指针建立了命令名称<code>get</code>与处理函数<code>getCommand</code>的映射关系</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand &#123;</span><br><span class="line"> <span class="type">char</span> *name;</span><br><span class="line"> redisCommandProc *proc;</span><br><span class="line"> <span class="type">int</span> arity;</span><br><span class="line"> <span class="type">char</span> *sflags;   <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line"> uint64_t flags; <span class="comment">/* The actual flags, obtained from the &#x27;sflags&#x27; field. */</span></span><br><span class="line"> <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">  * Used for Redis Cluster redirect. */</span></span><br><span class="line"> redisGetKeysProc *getkeys_proc;</span><br><span class="line"> <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line"> <span class="type">int</span> firstkey; <span class="comment">/* The first argument that&#x27;s a key (0 = no keys) */</span></span><br><span class="line"> <span class="type">int</span> lastkey;  <span class="comment">/* The last argument that&#x27;s a key */</span></span><br><span class="line"> <span class="type">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> microseconds, calls;</span><br><span class="line"> <span class="type">int</span> id;     <span class="comment">/* Command ID. This is a progressive ID starting from 0 that</span></span><br><span class="line"><span class="comment">                is assigned at runtime, and is used in order to check</span></span><br><span class="line"><span class="comment">                ACLs. A connection is able to execute a given command if</span></span><br><span class="line"><span class="comment">                the user associated to the connection has this command</span></span><br><span class="line"><span class="comment">                bit set in the bitmap of allowed commands. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">populateCommandTable</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> <span class="type">int</span> <span class="variable">numcommands</span> <span class="operator">=</span> sizeof(redisCommandTable)/sizeof(struct redisCommand);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numcommands; j++) &#123;</span><br><span class="line">     struct redisCommand *c = redisCommandTable+j;</span><br><span class="line">     <span class="type">int</span> retval1, retval2;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Translate the command string flags description into an actual</span></span><br><span class="line"><span class="comment">      * set of flags. */</span></span><br><span class="line">     <span class="keyword">if</span> (populateCommandTableParseFlags(c,c-&gt;sflags) == C_ERR)</span><br><span class="line">         serverPanic(<span class="string">&quot;Unsupported command flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">     c-&gt;id = ACLGetCommandID(c-&gt;name); <span class="comment">/* Assign the ID used for ACL. */</span></span><br><span class="line">     retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</span><br><span class="line">     <span class="comment">/* Populate an additional dictionary that will be unaffected</span></span><br><span class="line"><span class="comment">      * by rename-command statements in redis.conf. */</span></span><br><span class="line">     retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</span><br><span class="line">     serverAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>config.c#loadServerConfig()</code> 函数主要加载服务端启动时的配置文件，将配置文件中的内容读取出来以字符串形式存储，再调用 <code>loadServerConfigFromString()</code> 函数将字符串解析成 server 的配置属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">loadServerConfig</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *options)</span> &#123;</span><br><span class="line"> <span class="type">sds</span> <span class="variable">config</span> <span class="operator">=</span> sdsempty();</span><br><span class="line"> <span class="type">char</span> buf[CONFIG_MAX_LINE+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Load the file content */</span></span><br><span class="line"> <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">     FILE *fp;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (filename[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; filename[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">         fp = stdin;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">&quot;r&quot;</span>)) == NULL) &#123;</span><br><span class="line">             serverLog(LL_WARNING,</span><br><span class="line">                 <span class="string">&quot;Fatal error, can&#x27;t open config file &#x27;%s&#x27;&quot;</span>, filename);</span><br><span class="line">             exit(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(fgets(buf,CONFIG_MAX_LINE+<span class="number">1</span>,fp) != NULL)</span><br><span class="line">         config = sdscat(config,buf);</span><br><span class="line">     <span class="keyword">if</span> (fp != stdin) fclose(fp);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* Append the additional options */</span></span><br><span class="line"> <span class="keyword">if</span> (options) &#123;</span><br><span class="line">     config = sdscat(config,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     config = sdscat(config,options);</span><br><span class="line"> &#125;</span><br><span class="line"> loadServerConfigFromString(config);</span><br><span class="line"> sdsfree(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>server.c#initServer()</code> 函数体很长，不过主要的逻辑可以归纳为以下几步。这其中<code>监听端口</code>，<code>创建 redisDb 数据结构</code>等所有步骤都比较简单，本文仅以 <code>aeCreateFileEvent()</code> 函数实现为例进行解析</p>
<blockquote>
<ol>
<li>初始化 server 服务端的各项配置属性，包括定时任务执行频率，客户端链表结构，Slave 节点链表结构等</li>
<li>调用 aeCreateEventLoop() 函数创建事件循环实例</li>
<li>调用 listenToPort() 函数绑定服务端 Socket 监听端口</li>
<li>初始化 redis 的 db 数据结构 redisDb，默认有 16 个</li>
<li>调用 aeCreateTimeEvent() 函数指定定时事件的处理函数为 serverCron()，其中包括主从节点及集群模式下各个节点的定时通信处理</li>
<li>调用 aeCreateFileEvent() 函数指定 Socket 可读事件的处理函数为 acceptTcpHandler()，用于处理新建连接</li>
<li>调用 aeSetBeforeSleepProc() 函数设置每次事件处理之前需要进行的操作为 beforeSleep()，该函数会有对过期数据的淘汰</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">initServer</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Initialization after setting defaults from the config system. */</span></span><br><span class="line"> server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;</span><br><span class="line"> server.hz = server.config_hz;</span><br><span class="line"> server.pid = getpid();</span><br><span class="line"> server.current_client = NULL;</span><br><span class="line"> server.fixed_time_expire = <span class="number">0</span>;</span><br><span class="line"> server.clients = listCreate();</span><br><span class="line"> server.clients_index = raxNew();</span><br><span class="line"> server.clients_to_close = listCreate();</span><br><span class="line"> server.slaves = listCreate();</span><br><span class="line"> server.monitors = listCreate();</span><br><span class="line"> server.clients_pending_write = listCreate();</span><br><span class="line"> server.clients_pending_read = listCreate();</span><br><span class="line"> server.clients_timeout_table = raxNew();</span><br><span class="line"> server.slaveseldb = -<span class="number">1</span>; <span class="comment">/* Force to emit the first SELECT command. */</span></span><br><span class="line"> server.unblocked_clients = listCreate();</span><br><span class="line"> server.ready_keys = listCreate();</span><br><span class="line"> server.clients_waiting_acks = listCreate();</span><br><span class="line"> server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line"> server.clients_paused = <span class="number">0</span>;</span><br><span class="line"> server.events_processed_while_blocked = <span class="number">0</span>;</span><br><span class="line"> server.system_memory_size = zmalloc_get_memory_size();</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line"> <span class="keyword">if</span> (server.el == NULL) &#123;</span><br><span class="line">     serverLog(LL_WARNING,</span><br><span class="line">         <span class="string">&quot;Failed creating the event loop. Error message: &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">         strerror(errno));</span><br><span class="line">     exit(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> server.db = zmalloc(sizeof(redisDb)*server.dbnum);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Open the TCP listening socket for the user commands. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">     listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">     exit(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (server.tls_port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">     listenToPort(server.tls_port,server.tlsfd,&amp;server.tlsfd_count) == C_ERR)</span><br><span class="line">     exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Open the listening Unix domain socket. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.unixsocket != NULL) &#123;</span><br><span class="line">     unlink(server.unixsocket); <span class="comment">/* don&#x27;t care if this fails */</span></span><br><span class="line">     server.sofd = anetUnixServer(server.neterr,server.unixsocket,</span><br><span class="line">         server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">     <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</span><br><span class="line">         serverLog(LL_WARNING, <span class="string">&quot;Opening Unix socket: %s&quot;</span>, server.neterr);</span><br><span class="line">         exit(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     anetNonBlock(NULL,server.sofd);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Abort if there are no listening sockets at all. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.ipfd_count == <span class="number">0</span> &amp;&amp; server.tlsfd_count == <span class="number">0</span> &amp;&amp; server.sofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     serverLog(LL_WARNING, <span class="string">&quot;Configured to not listen anywhere, exiting.&quot;</span>);</span><br><span class="line">     exit(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create the Redis databases, and initialize other internal state. */</span></span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">     server.db[j].dict = dictCreate(&amp;dbDictType,NULL);</span><br><span class="line">     server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL);</span><br><span class="line">     server.db[j].expires_cursor = <span class="number">0</span>;</span><br><span class="line">     server.db[j].blocking_keys = dictCreate(&amp;keylistDictType,NULL);</span><br><span class="line">     server.db[j].ready_keys = dictCreate(&amp;objectKeyPointerValueDictType,NULL);</span><br><span class="line">     server.db[j].watched_keys = dictCreate(&amp;keylistDictType,NULL);</span><br><span class="line">     server.db[j].id = j;</span><br><span class="line">     server.db[j].avg_ttl = <span class="number">0</span>;</span><br><span class="line">     server.db[j].defrag_later = listCreate();</span><br><span class="line">     listSetFreeMethod(server.db[j].defrag_later,(<span class="keyword">void</span> (*)(<span class="keyword">void</span>*))sdsfree);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create the timer callback, this is our way to process many background</span></span><br><span class="line"><span class="comment">  * operations incrementally, like clients timeout, eviction of unaccessed</span></span><br><span class="line"><span class="comment">  * expired keys and so forth. */</span></span><br><span class="line"> <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, NULL, NULL) == AE_ERR) &#123;</span><br><span class="line">     serverPanic(<span class="string">&quot;Can&#x27;t create event loop timers.&quot;</span>);</span><br><span class="line">     exit(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">  * domain sockets. */</span></span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">         acceptTcpHandler,NULL) == AE_ERR)</span><br><span class="line">         &#123;</span><br><span class="line">             serverPanic(</span><br><span class="line">                 <span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Register before and after sleep handlers (note this needs to be done</span></span><br><span class="line"><span class="comment">  * before loading persistence since it is used by processEventsWhileBlocked. */</span></span><br><span class="line"> aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line"> aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Open the AOF file if needed. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.aof_state == AOF_ON) &#123;</span><br><span class="line">     server.aof_fd = open(server.aof_filename,</span><br><span class="line">                            O_WRONLY|O_APPEND|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">     <span class="keyword">if</span> (server.aof_fd == -<span class="number">1</span>) &#123;</span><br><span class="line">         serverLog(LL_WARNING, <span class="string">&quot;Can&#x27;t open the append-only file: %s&quot;</span>,</span><br><span class="line">             strerror(errno));</span><br><span class="line">         exit(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 32 bit instances are limited to 4GB of address space, so if there is</span></span><br><span class="line"><span class="comment">  * no explicit limit in the user provided configuration we set a limit</span></span><br><span class="line"><span class="comment">  * at 3 GB using maxmemory with &#x27;noeviction&#x27; policy&#x27;. This avoids</span></span><br><span class="line"><span class="comment">  * useless crashes of the Redis instance for out of memory. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">     serverLog(LL_WARNING,<span class="string">&quot;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with &#x27;noeviction&#x27; policy now.&quot;</span>);</span><br><span class="line">     server.maxmemory = 3072LL*(<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* 3 GB */</span></span><br><span class="line">     server.maxmemory_policy = MAXMEMORY_NO_EVICTION;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (server.cluster_enabled) clusterInit();</span><br><span class="line"> replicationScriptCacheInit();</span><br><span class="line"> scriptingInit(<span class="number">1</span>);</span><br><span class="line"> slowlogInit();</span><br><span class="line"> latencyMonitorInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ae.c#aeCreateFileEvent()</code> 函数内部逻辑很简单，只是根据传入的 <code>AE_READABLE</code> 标志将函数 <code>acceptTcpHandler()</code> 赋给了文件事件的读处理指针 <code>rfileProc</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">     aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">     errno = ERANGE;</span><br><span class="line">     <span class="keyword">return</span> AE_ERR;</span><br><span class="line"> &#125;</span><br><span class="line"> aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == -<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">return</span> AE_ERR;</span><br><span class="line"> fe-&gt;mask |= mask;</span><br><span class="line"> <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line"> <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line"> fe-&gt;clientData = clientData;</span><br><span class="line"> <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">     eventLoop-&gt;maxfd = fd;</span><br><span class="line"> <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>server.c#aeMain()</code> 在服务端初始化完成后会<code>开启 while 循环</code>启动事件处理，其核心的函数为 <code>aeProcessEvents()</code></p>
<blockquote>
<p><code>aeProcessEvents()</code> 函数会处理两种事件，分别是<code>定时触发的事件</code>和<code>Socket I/O触发的读写事件</code>。因为 redis 是单线程的，这两种事件不可以同时处理，所以该函数中有一种时间分片的策略，简单来说就是<font style=background-color:#f8f840>首先计算当前时间距离最近的定时事件触发时的时间差 T，然后调用 <code>aeApiPoll()</code>设置轮询 Socket 的超时时间为 T，在超时时间内只处理 Socket 读写事件，超时时间到了后再调用 processTimeEvents() 函数处理定时事件</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line"> eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">     aeProcessEvents(eventLoop, AE_ALL_EVENTS|</span><br><span class="line">                                AE_CALL_BEFORE_SLEEP|</span><br><span class="line">                                AE_CALL_AFTER_SLEEP);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">processed</span> <span class="operator">=</span> <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line"> <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">  * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">  * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">  * to fire. */</span></span><br><span class="line"> <span class="keyword">if</span> (eventLoop-&gt;maxfd != -<span class="number">1</span> ||</span><br><span class="line">     ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">     <span class="type">int</span> j;</span><br><span class="line">     aeTimeEvent *shortest = NULL;</span><br><span class="line">     struct timeval tv, *tvp;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">         shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">     <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">         <span class="type">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">         aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">         tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* How many milliseconds we need to wait for the next</span></span><br><span class="line"><span class="comment">          * time event to fire? */</span></span><br><span class="line">         <span class="type">long</span> <span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span></span><br><span class="line">             (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">             shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">             tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">             tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">          * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">          * to zero */</span></span><br><span class="line">         <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">             tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">             tvp = &amp;tv;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">             tvp = NULL; <span class="comment">/* wait forever */</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">         tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">         tvp = &amp;tv;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (eventLoop-&gt;beforesleep != NULL &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">         eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Call the multiplexing API, will return only on timeout or when</span></span><br><span class="line"><span class="comment">      * some event fires. */</span></span><br><span class="line">     numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* After sleep callback. */</span></span><br><span class="line">     <span class="keyword">if</span> (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">         eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">         aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">         <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> eventLoop-&gt;fired[j].mask;</span><br><span class="line">         <span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> eventLoop-&gt;fired[j].fd;</span><br><span class="line">         <span class="type">int</span> <span class="variable">fired</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">          * event laster. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">          * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">          * query.</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * However if AE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">          * asking us to do the reverse: never fire the writable event</span></span><br><span class="line"><span class="comment">          * after the readable. In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">          * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">          * in the beforeSleep() hook, like fsynching a file to disk,</span></span><br><span class="line"><span class="comment">          * before replying to a client. */</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">invert</span> <span class="operator">=</span> fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Note the &quot;fe-&gt;mask &amp; mask &amp; ...&quot; code: maybe an already</span></span><br><span class="line"><span class="comment">          * processed event removed an element that fired and we still</span></span><br><span class="line"><span class="comment">          * didn&#x27;t processed, so we check if the event is still valid.</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * Fire the readable event if the call sequence is not</span></span><br><span class="line"><span class="comment">          * inverted. */</span></span><br><span class="line">         <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">             fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">             fired++;</span><br><span class="line">             fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">         <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">             <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                 fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                 fired++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">          * after the writable one. */</span></span><br><span class="line">         <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">             fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">             <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                 (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc))</span><br><span class="line">             &#123;</span><br><span class="line">                 fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                 fired++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         processed++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* Check time events */</span></span><br><span class="line"> <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">     processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Redis-命令执行流程"><a href="#Redis-命令执行流程" class="headerlink" title="Redis 命令执行流程"></a>Redis 命令执行流程</h1><ol>
<li><p>Redis 服务端启动完成后就可以接受客户端的连接了，当客户端连接请求到来时，会在服务端的事件轮询时轮询出可读事件进行处理，这样就会触发启动过程中设置的处理函数 <code>networking.c#acceptTcpHandler()</code>，在这个函数中调用 <code>connCreateAcceptedSocket()</code>创建客户端与服务端之间的 Socket，  <code>acceptCommonHandler() </code>函数将对新建的 Socket 进行相关设置处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="keyword">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line"> <span class="type">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span><br><span class="line"> <span class="type">char</span> cip[NET_IP_STR_LEN];</span><br><span class="line"> UNUSED(el);</span><br><span class="line"> UNUSED(mask);</span><br><span class="line"> UNUSED(privdata);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">     cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);</span><br><span class="line">     <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">         <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">             serverLog(LL_WARNING,</span><br><span class="line">                 <span class="string">&quot;Accepting client connection: %s&quot;</span>, server.neterr);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     serverLog(LL_VERBOSE,<span class="string">&quot;Accepted %s:%d&quot;</span>, cip, cport);</span><br><span class="line">     acceptCommonHandler(connCreateAcceptedSocket(cfd),<span class="number">0</span>,cip);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>networking.c#acceptCommonHandler() </code> 会调用 <code>createClient()</code> 新建一个 client 对象作为客户端的抽象，以便维护服务端与客户端之间的连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">acceptCommonHandler</span><span class="params">(connection *conn, <span class="type">int</span> flags, <span class="type">char</span> *ip)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create connection and client */</span></span><br><span class="line"> <span class="keyword">if</span> ((c = createClient(conn)) == NULL) &#123;</span><br><span class="line">     <span class="type">char</span> conninfo[<span class="number">100</span>];</span><br><span class="line">     serverLog(LL_WARNING,</span><br><span class="line">         <span class="string">&quot;Error registering fd event for the new client: %s (conn: %s)&quot;</span>,</span><br><span class="line">         connGetLastError(conn),</span><br><span class="line">         connGetInfo(conn, conninfo, sizeof(conninfo)));</span><br><span class="line">     connClose(conn); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Last chance to keep flags */</span></span><br><span class="line"> c-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Initiate accept.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Note that connAccept() is free to do two things here:</span></span><br><span class="line"><span class="comment">  * 1. Call clientAcceptHandler() immediately;</span></span><br><span class="line"><span class="comment">  * 2. Schedule a future call to clientAcceptHandler().</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Because of that, we must do nothing else afterwards.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">if</span> (connAccept(conn, clientAcceptHandler) == C_ERR) &#123;</span><br><span class="line">     <span class="type">char</span> conninfo[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_ERROR)</span><br><span class="line">         serverLog(LL_WARNING,</span><br><span class="line">                 <span class="string">&quot;Error accepting a client connection: %s (conn: %s)&quot;</span>,</span><br><span class="line">                 connGetLastError(conn), connGetInfo(conn, conninfo, sizeof(conninfo)));</span><br><span class="line">     freeClient(connGetPrivateData(conn));</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>networking.c#createClient()</code> 函数体比较长，不过主要逻辑可以归纳为以下几步：</p>
<blockquote>
<ol>
<li>如果连接已经建立成功，调用 connSetReadHandler() 函数将该连接上读处理器设置为 readQueryFromClient() </li>
<li>selectDb() 函数将客户端要操作的数据库默认设置为下标为 0 的数据库</li>
<li>设置客户端对象 client 的其他属性，调用 linkClient() 将新建的客户端加入到服务端维护的客户端链表尾部</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">client *createClient(connection *conn) &#123;</span><br><span class="line"> client *c = zmalloc(sizeof(client));</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* passing NULL as conn it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">  * This is useful since all the commands needs to be executed</span></span><br><span class="line"><span class="comment">  * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">  * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line"> <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">     connNonBlock(conn);</span><br><span class="line">     connEnableTcpNoDelay(conn);</span><br><span class="line">     <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">         connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">     connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">     connSetPrivateData(conn, c);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> selectDb(c,<span class="number">0</span>);</span><br><span class="line"> <span class="type">uint64_t</span> <span class="variable">client_id</span> <span class="operator">=</span> ++server.next_client_id;</span><br><span class="line"> c-&gt;id = client_id;</span><br><span class="line"> c-&gt;resp = <span class="number">2</span>;</span><br><span class="line"> c-&gt;conn = conn;</span><br><span class="line"> c-&gt;name = NULL;</span><br><span class="line"> c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line"> c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line"> c-&gt;querybuf = sdsempty();</span><br><span class="line"> c-&gt;pending_querybuf = sdsempty();</span><br><span class="line"> c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line"> c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line"> c-&gt;argc = <span class="number">0</span>;</span><br><span class="line"> c-&gt;argv = NULL;</span><br><span class="line"> c-&gt;cmd = c-&gt;lastcmd = NULL;</span><br><span class="line"> c-&gt;user = DefaultUser;</span><br><span class="line"> c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line"> c-&gt;bulklen = -<span class="number">1</span>;</span><br><span class="line"> c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line"> c-&gt;flags = <span class="number">0</span>;</span><br><span class="line"> c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line"> <span class="comment">/* If the default user does not require authentication, the user is</span></span><br><span class="line"><span class="comment">  * directly authenticated. */</span></span><br><span class="line"> c-&gt;authenticated = (c-&gt;user-&gt;flags &amp; USER_FLAG_NOPASS) &amp;&amp;</span><br><span class="line">                    !(c-&gt;user-&gt;flags &amp; USER_FLAG_DISABLED);</span><br><span class="line"> c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line"> c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line"> c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line"> c-&gt;read_reploff = <span class="number">0</span>;</span><br><span class="line"> c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line"> c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line"> c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line"> c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line"> c-&gt;reply = listCreate();</span><br><span class="line"> c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line"> c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line"> listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line"> listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line"> c-&gt;btype = BLOCKED_NONE;</span><br><span class="line"> c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line"> c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,NULL);</span><br><span class="line"> c-&gt;bpop.target = NULL;</span><br><span class="line"> c-&gt;bpop.xread_group = NULL;</span><br><span class="line"> c-&gt;bpop.xread_consumer = NULL;</span><br><span class="line"> c-&gt;bpop.xread_group_noack = <span class="number">0</span>;</span><br><span class="line"> c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line"> c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line"> c-&gt;woff = <span class="number">0</span>;</span><br><span class="line"> c-&gt;watched_keys = listCreate();</span><br><span class="line"> c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,NULL);</span><br><span class="line"> c-&gt;pubsub_patterns = listCreate();</span><br><span class="line"> c-&gt;peerid = NULL;</span><br><span class="line"> c-&gt;client_list_node = NULL;</span><br><span class="line"> c-&gt;client_tracking_redirection = <span class="number">0</span>;</span><br><span class="line"> c-&gt;client_tracking_prefixes = NULL;</span><br><span class="line"> c-&gt;client_cron_last_memory_usage = <span class="number">0</span>;</span><br><span class="line"> c-&gt;client_cron_last_memory_type = CLIENT_TYPE_NORMAL;</span><br><span class="line"> c-&gt;auth_callback = NULL;</span><br><span class="line"> c-&gt;auth_callback_privdata = NULL;</span><br><span class="line"> c-&gt;auth_module = NULL;</span><br><span class="line"> listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line"> listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line"> <span class="keyword">if</span> (conn) linkClient(c);</span><br><span class="line"> initClientMultiState(c);</span><br><span class="line"> <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>connection.h#connSetReadHandler()</code>函数会设置连接上的读处理函数，不过因为这里使用了函数指针，所以其最终调用到的方法其实是<code>connection.c#connSocketSetReadHandler()</code>。可以看到 connSocketSetReadHandler() 函数主要做了两件事：</p>
<blockquote>
<ol>
<li>首先调用<code>conn-&gt;read_handler = func</code> 设置了连接上的读处理器为传入的函数 readQueryFromClient()</li>
<li>调用 aeCreateFileEvent() 注册了一个事件循环中的文件事件，将函数指针 <code>ae_handler</code> 指向的函数 connSocketEventHandler() 作为读事件处理器</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connection.h</span></span><br><span class="line"><span class="keyword">static</span> inline <span class="type">int</span> <span class="title function_">connSetReadHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> conn-&gt;type-&gt;set_read_handler(conn, func);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// connection.c</span></span><br><span class="line"><span class="type">ConnectionType</span> <span class="variable">CT_Socket</span> <span class="operator">=</span> &#123;</span><br><span class="line"> .ae_handler = connSocketEventHandler,</span><br><span class="line"> .close = connSocketClose,</span><br><span class="line"> .write = connSocketWrite,</span><br><span class="line"> .read = connSocketRead,</span><br><span class="line"> .accept = connSocketAccept,</span><br><span class="line"> .connect = connSocketConnect,</span><br><span class="line"> .set_write_handler = connSocketSetWriteHandler,</span><br><span class="line"> .set_read_handler = connSocketSetReadHandler,</span><br><span class="line"> .get_last_error = connSocketGetLastError,</span><br><span class="line"> .blocking_connect = connSocketBlockingConnect,</span><br><span class="line"> .sync_write = connSocketSyncWrite,</span><br><span class="line"> .sync_read = connSocketSyncRead,</span><br><span class="line"> .sync_readline = connSocketSyncReadLine</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">connSocketSetReadHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (func == conn-&gt;read_handler) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"> conn-&gt;read_handler = func;</span><br><span class="line"> <span class="keyword">if</span> (!conn-&gt;read_handler)</span><br><span class="line">     aeDeleteFileEvent(server.el,conn-&gt;fd,AE_READABLE);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (aeCreateFileEvent(server.el,conn-&gt;fd,</span><br><span class="line">                 AE_READABLE,conn-&gt;type-&gt;ae_handler,conn) == AE_ERR) <span class="keyword">return</span> C_ERR;</span><br><span class="line"> <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>connection.c#connSocketEventHandler()</code> 函数将在客户端发送命令后，服务端轮询到可读事件时触发。可以看到，其内部逻辑是根据事件类型触发不同的处理函数，则对于读事件将触发连接上的读处理函数 <code>readQueryFromClient()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">connSocketEventHandler</span><span class="params">(struct aeEventLoop *el, <span class="type">int</span> fd, <span class="keyword">void</span> *clientData, <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">  * event later. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">  * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">  * query.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * However if WRITE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">  * asking us to do the reverse: never fire the writable event</span></span><br><span class="line"><span class="comment">  * after the readable. In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">  * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">  * in the beforeSleep() hook, like fsync&#x27;ing a file to disk,</span></span><br><span class="line"><span class="comment">  * before replying to a client. */</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">invert</span> <span class="operator">=</span> conn-&gt;flags &amp; CONN_FLAG_WRITE_BARRIER;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="variable">call_write</span> <span class="operator">=</span> (mask &amp; AE_WRITABLE) &amp;&amp; conn-&gt;write_handler;</span><br><span class="line"> <span class="type">int</span> <span class="variable">call_read</span> <span class="operator">=</span> (mask &amp; AE_READABLE) &amp;&amp; conn-&gt;read_handler;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Handle normal I/O flows */</span></span><br><span class="line"> <span class="keyword">if</span> (!invert &amp;&amp; call_read) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!callHandler(conn, conn-&gt;read_handler)) <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* Fire the writable event. */</span></span><br><span class="line"> <span class="keyword">if</span> (call_write) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!callHandler(conn, conn-&gt;write_handler)) <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">  * after the writable one. */</span></span><br><span class="line"> <span class="keyword">if</span> (invert &amp;&amp; call_read) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!callHandler(conn, conn-&gt;read_handler)) <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>networking.c#readQueryFromClient()</code>函数<font style=background-color:#f8f840>从 Socket 中读取出客户端传输的数据</font>，然后调用 <code>processInputBuffer()</code>函数将这些数据处理成字符串命令以便进行进一步处理。<code>processInputBuffer()</code>函数内部逻辑如下：</p>
<blockquote>
<ol>
<li>根据请求类型处理客户端传输过来的数据，processInlineBuffer() 处理 telnet 发送的 PING 等内联命令，processMultibulkBuffer() 处理批量命令包括 get&#x2F;set 等</li>
<li>processCommandAndResetClient() 函数开始执行解析出来的命令字符串</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line"> <span class="comment">/* Keep processing while there is something in the input buffer */</span></span><br><span class="line"> <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">     <span class="comment">/* Return if clients are paused. */</span></span><br><span class="line">     <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; clientsArePaused()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Immediately abort if the client is in the middle of something. */</span></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_BLOCKED) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Don&#x27;t process more buffers from clients that have already pending</span></span><br><span class="line"><span class="comment">      * commands to execute in c-&gt;argv. */</span></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Don&#x27;t process input from the master while there is a busy script</span></span><br><span class="line"><span class="comment">      * condition on the slave. We want just to accumulate the replication</span></span><br><span class="line"><span class="comment">      * stream (instead of replying -BUSY like we do with other clients) and</span></span><br><span class="line"><span class="comment">      * later resume the processing. */</span></span><br><span class="line">     <span class="keyword">if</span> (server.lua_timedout &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is</span></span><br><span class="line"><span class="comment">      * written to the client. Make sure to not let the reply grow after</span></span><br><span class="line"><span class="comment">      * this flag has been set (i.e. don&#x27;t process more commands).</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * The same applies for clients we want to terminate ASAP. */</span></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Determine request type when unknown. */</span></span><br><span class="line">     <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</span><br><span class="line">         <span class="keyword">if</span> (c-&gt;querybuf[c-&gt;qb_pos] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">             c-&gt;reqtype = PROTO_REQ_MULTIBULK;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             c-&gt;reqtype = PROTO_REQ_INLINE;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">         <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">/* If the Gopher mode and we got zero or one argument, process</span></span><br><span class="line"><span class="comment">          * the request in Gopher mode. */</span></span><br><span class="line">         <span class="keyword">if</span> (server.gopher_enabled &amp;&amp;</span><br><span class="line">             ((c-&gt;argc == <span class="number">1</span> &amp;&amp; ((<span class="type">char</span>*)(c-&gt;argv[<span class="number">0</span>]-&gt;ptr))[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) ||</span><br><span class="line">               c-&gt;argc == <span class="number">0</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             processGopherRequest(c);</span><br><span class="line">             resetClient(c);</span><br><span class="line">             c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">         <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         serverPanic(<span class="string">&quot;Unknown request type&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Multibulk processing could see a &lt;= 0 length. */</span></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">         resetClient(c);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* If we are in the context of an I/O thread, we can&#x27;t really</span></span><br><span class="line"><span class="comment">          * execute the command here. All we can do is to flag the client</span></span><br><span class="line"><span class="comment">          * as one that needs to process the command. */</span></span><br><span class="line">         <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_READ) &#123;</span><br><span class="line">             c-&gt;flags |= CLIENT_PENDING_COMMAND;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* We are finally ready to execute the command. */</span></span><br><span class="line">         <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">             <span class="comment">/* If the client is no longer valid, we avoid exiting this</span></span><br><span class="line"><span class="comment">              * loop and trimming the client buffer later. So we return</span></span><br><span class="line"><span class="comment">              * ASAP in that case. */</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Trim to pos */</span></span><br><span class="line"> <span class="keyword">if</span> (c-&gt;qb_pos) &#123;</span><br><span class="line">     sdsrange(c-&gt;querybuf,c-&gt;qb_pos,-<span class="number">1</span>);</span><br><span class="line">     c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>networking.c#processCommandAndResetClient()</code> 逻辑其实很简单，重点是调用<code>processCommand()</code> 函数，<code>processCommand()</code> 函数源码如下</p>
<blockquote>
<ol>
<li>首先调用 <code>lookupCommand()</code> 函数将客户端传入的命令名称入参，从服务端启动过程中存储的命令列表中找到对应的 redisCommand</li>
<li>如果 redis 以 cluster 集群模式启动，需要调用 getNodeByQuery() 找到 key 所在的 slot 是否应该交给当前服务端处理，不是的话调用 <code>clusterRedirectClient()</code> 告诉客户端应该去找哪个服务端</li>
<li>异常情况的检测，包括是否超过内存限制、是否合法命令等</li>
<li>如果是事务执行命令， 除 EXEC 、 DISCARD 、 MULTI 和 WATCH 命令之外其他命令都会被函数 <code>queueMultiCommand()</code> 入队到事务队列中处理</li>
<li>如果是常规命令，调用  <code>call()</code> 函数执行命令</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Now lookup the command and check ASAP about trivial error conditions</span></span><br><span class="line"><span class="comment">  * such as wrong arity, bad command name and so forth. */</span></span><br><span class="line"> c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* If cluster is enabled perform the cluster redirection here.</span></span><br><span class="line"><span class="comment">  * However we don&#x27;t perform the redirection if:</span></span><br><span class="line"><span class="comment">  * 1) The sender of this command is our master.</span></span><br><span class="line"><span class="comment">  * 2) The command has no key arguments. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">     !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">     !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">       server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">     !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">       c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> hashslot;</span><br><span class="line">     <span class="type">int</span> error_code;</span><br><span class="line">     clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                     &amp;hashslot,&amp;error_code);</span><br><span class="line">     <span class="keyword">if</span> (n == NULL || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">         <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">             discardTransaction(c);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             flagTransaction(c);</span><br><span class="line">         &#125;</span><br><span class="line">         clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">         <span class="keyword">return</span> C_OK;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Exec the command */</span></span><br><span class="line"> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">     c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">     c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line"> &#123;</span><br><span class="line">     queueMultiCommand(c);</span><br><span class="line">     addReply(c,shared.queued);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     call(c,CMD_CALL_FULL);</span><br><span class="line">     c-&gt;woff = server.master_repl_offset;</span><br><span class="line">     <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">         handleClientsBlockedOnKeys();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>server.c#call()</code> 函数的逻辑主要分为两个步骤，<font style=background-color:#f8f840>下文命令执行以 set 命令为例</font></p>
<blockquote>
<ol>
<li><code>c-&gt;cmd-&gt;proc( c )</code> 会调用客户端命令对应的 redisCommand 的处理方法，以 set 命令为例，会调用到 <code>t_string.c#setCommand()</code>方法</li>
<li>调用 <code>propagate()</code>函数同步数据到 AOF 文件和 slave节点。该函数会根据服务端相关配置决定同步策略，其中调用 <code>feedAppendOnlyFile()</code> 函数会同步命令到AOF文件，<code>replicationFeedSlaves()</code> 同步命令到 Slave 节点</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">call</span><span class="params">(client *c, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Call the command. */</span></span><br><span class="line"> dirty = server.dirty;</span><br><span class="line"> updateCachedTime(<span class="number">0</span>);</span><br><span class="line"> start = server.ustime;</span><br><span class="line"> c-&gt;cmd-&gt;proc(c);</span><br><span class="line"> duration = ustime()-start;</span><br><span class="line"> dirty = server.dirty-dirty;</span><br><span class="line"> <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line"> <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">     (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">propagate_flags</span> <span class="operator">=</span> PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Check if the command operated changes in the data set. If so</span></span><br><span class="line"><span class="comment">      * set for replication / AOF propagation. */</span></span><br><span class="line">     <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* If the client forced AOF / replication of the command, set</span></span><br><span class="line"><span class="comment">      * the flags regardless of the command effects on the data set. */</span></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* However prevent AOF / replication propagation if the command</span></span><br><span class="line"><span class="comment">      * implementations called preventCommandPropagation() or similar,</span></span><br><span class="line"><span class="comment">      * or if we don&#x27;t have the call() flags to do so. */</span></span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span><br><span class="line">         !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">             propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">     <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span><br><span class="line">         !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">             propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Call propagate() only if at least one of AOF / replication</span></span><br><span class="line"><span class="comment">      * propagation is needed. Note that modules commands handle replication</span></span><br><span class="line"><span class="comment">      * in an explicit way, so we never replicate them automatically. */</span></span><br><span class="line">     <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">         propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Restore the old replication flags, since call() can be executed</span></span><br><span class="line"><span class="comment">  * recursively. */</span></span><br><span class="line"> c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line"> c-&gt;flags |= client_old_flags &amp;</span><br><span class="line">     (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Handle the alsoPropagate() API to handle commands that want to propagate</span></span><br><span class="line"><span class="comment">  * multiple separated commands. Note that alsoPropagate() is not affected</span></span><br><span class="line"><span class="comment">  * by CLIENT_PREVENT_PROP flag. */</span></span><br><span class="line"> <span class="keyword">if</span> (server.also_propagate.numops) &#123;</span><br><span class="line">     <span class="type">int</span> j;</span><br><span class="line">     redisOp *rop;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">multi_emitted</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="comment">/* Wrap the commands in server.also_propagate array,</span></span><br><span class="line"><span class="comment">          * but don&#x27;t wrap it if we are already in MULTI context,</span></span><br><span class="line"><span class="comment">          * in case the nested MULTI/EXEC.</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * And if the array contains only one command, no need to</span></span><br><span class="line"><span class="comment">          * wrap it, since the single command is atomic. */</span></span><br><span class="line">         <span class="keyword">if</span> (server.also_propagate.numops &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">             !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE) &amp;&amp;</span><br><span class="line">             !(c-&gt;flags &amp; CLIENT_MULTI) &amp;&amp;</span><br><span class="line">             !(flags &amp; CMD_CALL_NOWRAP))</span><br><span class="line">         &#123;</span><br><span class="line">             execCommandPropagateMulti(c);</span><br><span class="line">             multi_emitted = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.also_propagate.numops; j++) &#123;</span><br><span class="line">             rop = &amp;server.also_propagate.ops[j];</span><br><span class="line">             <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> rop-&gt;target;</span><br><span class="line">             <span class="comment">/* Whatever the command wish is, we honor the call() flags. */</span></span><br><span class="line">             <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span><br><span class="line">             <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span><br><span class="line">             <span class="keyword">if</span> (target)</span><br><span class="line">                 propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (multi_emitted) &#123;</span><br><span class="line">             execCommandPropagateExec(c);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     redisOpArrayFree(&amp;server.also_propagate);</span><br><span class="line"> &#125;</span><br><span class="line"> server.also_propagate = prev_also_propagate;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If the client has keys tracking enabled for client side caching,</span></span><br><span class="line"><span class="comment">  * make sure to remember the keys it fetched via this command. */</span></span><br><span class="line"> <span class="keyword">if</span> (c-&gt;cmd-&gt;flags &amp; CMD_READONLY) &#123;</span><br><span class="line">     client *caller = (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) ?</span><br><span class="line">                         server.lua_caller : c;</span><br><span class="line">     <span class="keyword">if</span> (caller-&gt;flags &amp; CLIENT_TRACKING &amp;&amp;</span><br><span class="line">         !(caller-&gt;flags &amp; CLIENT_TRACKING_BCAST))</span><br><span class="line">     &#123;</span><br><span class="line">         trackingRememberKeys(caller);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> server.fixed_time_expire--;</span><br><span class="line"> server.stat_numcommands++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>t_string.c#setCommand()</code> 函数的核心是调用 <code>setGenericCommand()</code> 函数， 该函数源码如下，可以看到其内部逻辑首先会检查命令参数，之后调用 <code>genericSetKey()</code> 将数据添加到 redisDb 中。至此 redis 命令执行结束，<code>networking.c#addReply()</code> 函数将把服务端对客户端的响应写入到缓冲区，发送给客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setGenericCommand</span><span class="params">(client *c, <span class="type">int</span> flags, robj *key, robj *val, robj *expire, <span class="type">int</span> unit, robj *ok_reply, robj *abort_reply)</span> &#123;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> <span class="variable">milliseconds</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">     <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         addReplyErrorFormat(c,<span class="string">&quot;invalid expire time in %s&quot;</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</span><br><span class="line">     (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</span><br><span class="line"> &#123;</span><br><span class="line">     addReply(c, abort_reply ? abort_reply : shared.<span class="literal">null</span>[c-&gt;resp]);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> genericSetKey(c,c-&gt;db,key,val,flags &amp; OBJ_SET_KEEPTTL,<span class="number">1</span>);</span><br><span class="line"> server.dirty++;</span><br><span class="line"> <span class="keyword">if</span> (expire) setExpire(c,c-&gt;db,key,mstime()+milliseconds);</span><br><span class="line"> notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line"> <span class="keyword">if</span> (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">     <span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line"> addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数<code>db.c#genericSetKey()</code>  的核心处理主要分为了以下几个步骤：</p>
<blockquote>
<ol>
<li>调用 <code>lookupKeyWrite()</code> 函数查找 redis 数据库中是否存在指定的 key，因为 redis 的数据库结构可以看成是 HashMap，故其查找方式与<a href="https://yang00-74.github.io/2023/05/29/Java-8-HashMap/#HashMap-get-%E6%96%B9%E6%B3%95"> Java 中 HashMap </a> 实现的方式相同。如指定 key 存在则调用 <code>dbOverwrite()</code> 函数覆盖指定 key 的 value ，如不存在则调用<code>dbAdd()</code>将 set 命令传入的 key-value 添加到数据库中</li>
<li>incrRefCount() 函数将 value 的引用计数加1</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">genericSetKey</span><span class="params">(client *c, redisDb *db, robj *key, robj *val, <span class="type">int</span> keepttl, <span class="type">int</span> signal)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lookupKeyWrite(db,key) == NULL) &#123;</span><br><span class="line">    dbAdd(db,key,val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dbOverwrite(db,key,val);</span><br><span class="line">&#125;</span><br><span class="line">incrRefCount(val);</span><br><span class="line"><span class="keyword">if</span> (!keepttl) removeExpire(db,key);</span><br><span class="line"><span class="keyword">if</span> (signal) signalModifiedKey(c,db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yang00-74.github.io">nathan.yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yang00-74.github.io/2023/05/30/Redis-1/">https://yang00-74.github.io/2023/05/30/Redis-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yang00-74.github.io" target="_blank">谈谈1974</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/30/Redis-2/" title="Redis 6.0 源码阅读笔记(2)-Redis 多线程原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 6.0 源码阅读笔记(2)-Redis 多线程原理</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/29/Netty-4/" title="Netty源码分析(4)-SubReactor 读写数据流程解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty源码分析(4)-SubReactor 读写数据流程解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/02/Redis-3/" title="Redis 6.0 源码阅读笔记(3)-概述 Redis 重要数据结构及其 6 种数据类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">Redis 6.0 源码阅读笔记(3)-概述 Redis 重要数据结构及其 6 种数据类型</div></div></a></div><div><a href="/2023/06/02/Redis-4/" title="Redis 6.0 源码阅读笔记(4)-String 数据类型源码分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">Redis 6.0 源码阅读笔记(4)-String 数据类型源码分析</div></div></a></div><div><a href="/2023/06/06/Redis-cluster/" title="RedisCluster 集群实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">RedisCluster 集群实现原理</div></div></a></div><div><a href="/2023/06/08/Redis-rdb/" title="Redis 持久化 RDB 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-08</div><div class="title">Redis 持久化 RDB 详解</div></div></a></div><div><a href="/2023/06/05/Redis-concept/" title="Redis 指南(1)-重要概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-05</div><div class="title">Redis 指南(1)-重要概念</div></div></a></div><div><a href="/2023/06/06/Redis-13/" title="Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">nathan.yang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yang00-74"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to nathan blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Redis 服务端启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">Redis 命令执行流程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/OpenSIPS-4/" title="OpenSIPS OutOfMemory 崩溃处理">OpenSIPS OutOfMemory 崩溃处理</a><time datetime="2023-09-13T07:20:29.000Z" title="发表于 2023-09-13 15:20:29">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/02/OpenSIPS-3/" title="OpenSIPS 管理接口的对接">OpenSIPS 管理接口的对接</a><time datetime="2023-09-02T05:25:56.000Z" title="发表于 2023-09-02 13:25:56">2023-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/29/Rtpengine-1/" title="RTPEngine 通过 HTTP 获取指标的方式">RTPEngine 通过 HTTP 获取指标的方式</a><time datetime="2023-08-29T07:10:34.000Z" title="发表于 2023-08-29 15:10:34">2023-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/26/SIP-1/" title="SIP 协议路由规则详解">SIP 协议路由规则详解</a><time datetime="2023-08-26T07:13:25.000Z" title="发表于 2023-08-26 15:13:25">2023-08-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/25/OpenSIPS-2/" title="OpenSIPS 通话中 UPDATE 请求导致没有声音问题">OpenSIPS 通话中 UPDATE 请求导致没有声音问题</a><time datetime="2023-08-25T09:58:32.000Z" title="发表于 2023-08-25 17:58:32">2023-08-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By nathan.yang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="点,啥,呢" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>