<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>谈谈1974</title><meta name="author" content="nathan.yang"><meta name="copyright" content="nathan.yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="谈谈1974">
<meta property="og:url" content="https://yang00-74.github.io/page/2/index.html">
<meta property="og:site_name" content="谈谈1974">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:author" content="nathan.yang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/drogan.jpg"><link rel="canonical" href="https://yang00-74.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '谈谈1974',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-09-13 17:47:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="谈谈1974"><span class="site-name">谈谈1974</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">谈谈1974</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/09/Java-memory-high/" title="Java 服务内存占用过高的一次排查过程">Java 服务内存占用过高的一次排查过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-09T03:15:23.000Z" title="发表于 2023-06-09 11:15:23">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Java-%E5%9F%BA%E7%A1%80/JVM/">JVM</a></span></div><div class="content">问题发生日常敲代码时，运维同事突然把小组人员都拉进了一个群里，说一台线上机器内存耗尽，OOM 导致服务注册的 Mesh 客户端被干掉了，部分服务调用异常。运维同事查看机器负载，发现我们组内一个Java 服务占用的内存有点异常，启动命令 -Xmx128m 指定了最大堆内存只有 128M，但是整个进程占用的内存达到了 640M，显然是有问题的
线上排查运维截图一扔，锅是甩不掉的，老老实实登录到线上机器排查。内存占用过高首先想到的就是发生了内存泄露，使用 jmap -histo $pid &gt; heap.log 输出堆内对象统计情况到文件中，查看文件发现堆中占用内存最多的是各种数组，没有发现明显的问题。没法子，使用 top -H p $pid 命令检查该进程内运行的线程状况，终于发现了可疑点，在这个Java 服务里面运行的子线程居然有 5000 个，并且几乎全部都在 Sleeping 状态
这种情况首先想到的是发生了线程死锁，资源争用导致大量线程被阻塞了。使用 jstack -l $pid &gt; stack.log 将线程栈相关状况输出到文件中，打开文件一搜索却大失所望，根本没有死锁 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/08/Redis-rdb/" title="Redis 持久化 RDB 详解">Redis 持久化 RDB 详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-08T08:23:11.000Z" title="发表于 2023-06-08 16:23:11">2023-06-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">前言Redis 是基于内存的 KV 数据库，使用时所有数据都在内存中，这就是它存取性能高的重要原因之一。但是如我们所知，保存在内存中的数据是有风险的，一旦机器停电或者意外宕机就会彻底丢失
Redis 持久化机制就是为了应对这种情况，其主要手段是将内存中的数据保存到磁盘上，宕机重启后再通过磁盘上的持久化文件将数据恢复。RDB 是 Redis 持久化机制的一种，它会将内存中的所有数据进行快照保存，并且以二进制文件形式存储到硬盘上
RDB 文件持久化的优缺点相对于Redis 的另一种持久化机制 AOF 来说， RDB 持久化的优缺点可以总结如下：


优点


RDB 文件保存的是 Redis 在某个时间点的数据集，二进制形式使其占用磁盘空间很小，非常适于备份和灾难恢复
生成RDB文件的时候，Redis 主进程可以 fork 一个子进程来处理所有保存工作，主进程可以继续提供服务，不需要进行任何磁盘IO操作
RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快，这是因为 RDB 文件直接加载进内存就可以恢复数据，AOF 文件加载进内存的是一条条 Redis 命令，需要执行后才能恢复数据

 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/08/Java-memory-leak/" title="Java 使用 VisualVM 排查内存泄露">Java 使用 VisualVM 排查内存泄露</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-08T01:42:10.000Z" title="发表于 2023-06-08 09:42:10">2023-06-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Java-%E5%9F%BA%E7%A1%80/JVM/">JVM</a></span></div><div class="content">问题发生线上突发告警，笔者负责的一个服务老年代内存使用率到达 75% 阈值，于是立即登录监控系统查看数据。拉长时间周期，查看最近 7 天的 GC 和老年代内存占用，监控截图如下。可以看到老年代占用内存的最低点在逐步抬升，初步判断是发生了内存泄露

排查过程初步排查从监控上看，这个服务的两个实例老年代内存占用情况并不一致，其中疑似发生内存泄露的是跑脚本的机器。于是登录到目标机器，首先执行 jmap -histo 1 | head -n 100 命令查看目标进程的堆内存占用前 100 的对象，发现其中 SkyWalking 的一个 trace 追踪对象 NoopSpan 实例总数达到了 2600 万之巨，内存占用也达到 600M，明显不正常
Visual VM 内存分析由于生产环境控制严格，不允许在线 dump 堆内存数据，于是在预发环境执行 jmap -dump:format=b,file=/tmp/dump 1 命令，将有相同问题的 java 进程的堆内存 dump 下来。下载拿到 dump 文件后，需要打开 VisualVM 加载该文件，以下为操作步骤

首先打开 VisualVM， ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/06/Redis-13/" title="Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程">Redis 6.0 源码阅读笔记(13)-Redis 集群节点选举流程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-06T12:44:54.000Z" title="发表于 2023-06-06 20:44:54">2023-06-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="content">集群选举的处理在 RedisCluster 集群实现原理 中提到过从节点通过选举晋升为主节点的过程，其处理大致如下：


Slave 节点在每个周期任务中都会检查 Master 节点是否 FAIL，如是则尝试进行 Failover，以期成为新的 Master。不过在此之前需要过滤可用的 Slave 节点，具体做法就是检查每个 Slave 节点与 Master 节点断开连接的时间，如果超过了cluster-node-timeout * cluster-slave-validity-factor，那这个Slave 节点就没有资格切换成 Master
由于挂掉的 Master 可能会有多个 Slave 节点，所以在 Slave 节点发起选举前需要根据所有 Slave 节点的 复制偏移量确定一个选举的优先级，Slave 节点的优先级越小则其发起选举的时间越靠前
当 Slave 节点到达其选举时间时，将自身的 currentEpoch 变量（该变量可视作集群所处版本的记录）自增，然后向集群中所有的节点发送 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息，请求其他 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/06/Redis-12/" title="Redis 6.0 源码阅读笔记(12)-Redis 集群建立流程">Redis 6.0 源码阅读笔记(12)-Redis 集群建立流程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-06T12:31:52.000Z" title="发表于 2023-06-06 20:31:52">2023-06-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="content">Redis 集群在 RedisCluster 集群实现原理 中已经介绍过 Redis 3.0 版本以后可使用 RedisCluster 作为分布式解决方案，其整个集群网络的建立依赖 Gossip 协议。以下为 Redis 集群建立的示意图，其大致处理流程为以下几个步骤：


节点A 邀请 节点B 加入集群，节点A 与 节点B 建立连接
节点A 邀请 节点C 加入集群，节点A 与 节点C 建立连接。二者通信时节点 A 将 节点B 的IP地址、端口号等信息发送给 节点C，节点C 保存并使用该信息去连接 节点B，节点C 与 节点B 建立连接
节点A 邀请 节点D 加入集群，节点A 与 节点D 建立连接。二者通信时节点 A 将 节点B、节点C 的IP地址、端口号等信息发送给 节点D，节点D 保存并使用该信息去连接 节点B 和 节点C，节点D 与 节点B 和 节点C 建立连接



关键数据结构集群状态 clusterStateclusterState 的结构定义在cluster.h文件中，集群中每一个节点都存在这样一个结构体，用来描述在本节点视角上整个集群的状态，比较关键的属性如下：


*m ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/06/Redis-cluster/" title="RedisCluster 集群实现原理">RedisCluster 集群实现原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-06T12:25:19.000Z" title="发表于 2023-06-06 20:25:19">2023-06-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Redis/">Redis</a></span></div><div class="content">RedisCluster 的架构要支持集群首先要克服数据分片问题，也就是一致性哈希问题，常见方案有以下几种：


客户端分片使用类似于哈希取模的做法，当客户端对服务端的数量完全掌握和控制时，可以简单使用
中间层分片在客户端和服务器端之间增加中间层，充当管理者和调度者，客户端的请求打向中间层，由中间层实现请求的转发和响应的回收，中间层最重要的作用是对多台服务器的动态管理
服务端分片实现去中心化的管理模式，客户端直接向服务器中任意结点请求，如果被请求的节点没有所需数据，则向客户端回复MOVED，并告诉客户端所需数据的存储位置，这个过程实际上是客户端和服务端共同配合，进行请求重定向来完成的


从 Redis 3.0 版本之后，Redis 支持 RedisCluster 集群作为分布式解决方案。该集群采用多主多从结构，实现了服务端的分片技术，使用多个 Master节点保存数据和整个集群状态，通过增减 Master节点就能达到增大&#x2F;缩小 Redis 数据容量的目的，从而很好地支持横向扩容。 官方传送门

Redis Cluster 集群的结构特点如下：


集群内支持多个 Maste ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/06/Redis-11/" title="Redis 6.0 源码阅读笔记(11)-主从复制 Slave 节点流程分析">Redis 6.0 源码阅读笔记(11)-主从复制 Slave 节点流程分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-06T12:10:35.000Z" title="发表于 2023-06-06 20:10:35">2023-06-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="content">主从复制中 Slave 节点的处理Slave 节点主从复制的处理从建立从属关系开始，以下为大致的处理步骤：


Slave 节点接收 slaveof 、replicaof 命令，进行从属关系的处理
根据命令参数处理命令，因为也有可能是移除从属关系的操作
如果是建立从属关系的命令，经过初步校验，保存下主节点的相关信息，并将当前节点的同步状态设置为 REPL_STATE_CONNECT
定时任务检查到当前节点的同步状态为 REPL_STATE_CONNECT，则需要与主节点建立连接，连接成功后开始进行数据同步
同步数据前 Slave 节点需要与 Master 节点交互，约定数据同步的方式以及数据传输的形式，确定后等待 Master 节点传输数据
从节点清空 db 数据，接收主节点传输过来的 rdb 数据，并将其加载到 db 中



处理流程分析
主从连接的建立
当 Redis 节点收到 slaveof 或者 replicaof 命令时会触发从属关系处理的函数 replication.c#replicaofCommand()，该函数只是个入口，处理逻辑较为简单：


首先是常规的状态检查， ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/06/Redis-10/" title="Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析">Redis 6.0 源码阅读笔记(10)-主从复制 Master 节点流程分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-06T12:10:29.000Z" title="发表于 2023-06-06 20:10:29">2023-06-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="content">主从复制中 Master 节点的处理Redis 主从复制 一节中粗略介绍过 Redis 的主从复制存在两种模式，以下则是 Master 节点对于主从复制的处理：


接收 Slave 节点的 psync 命令
判断是否可以执行部分复制，可以的话回复 +CONTINUE 给 Slave 节点，并将缓冲区命令直接发送给 Slave 节点，完成同步；不可以执行部分复制，只能全量复制，则回复 +FULLRESYNC 给 Slave 节点，根据情况做下一步处理
Master 节点存在可以复用的 rdb 数据，则直接将其发送给 Slave 节点，否则新起一个进程异步生成 rdb 数据
如果 Slave 节点同步配置可以直接通过 socket 发送 rdb 数据则直接发送，否则 Master 节点需要保存 rdb 数据到 rdb 文件
Master 节点定时任务周期检查 rdb 文件是否保存完毕，完成则发送 rdb 文件到 Slave 节点
最后发送 rdb 文件生成过程中缓存的 redis 执行命令给 Slave 节点



处理流程分析
psync 命令的大致处理
Redis 中对 psync  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/05/Redis-9/" title="Redis 6.0 源码阅读笔记(9)-数据淘汰原理">Redis 6.0 源码阅读笔记(9)-数据淘汰原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-05T06:11:36.000Z" title="发表于 2023-06-05 14:11:36">2023-06-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Redis 源码阅读笔记</a></span></div><div class="content">过期时间的存储在 redisDb 数据结构 一节中已经提到过，redis 数据库中有一个专门的 expires 字典用于存储显式设置了过期时间的数据(如 SETEX 命令设置的数据)。本节以 SETEX 命令为例，依据源码分析过期时间的设置过程
1234567891011typedef struct redisDb &#123;    dict *dict;                 /* The keyspace for this DB */    dict *expires;              /* Timeout of keys with a timeout set */    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/    dict *ready_keys;           /* Blocked keys that received a PUSH */    dict *watched_keys;         /* WATCHED keys for ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2023/06/05/Redis-concept/" title="Redis 指南(1)-重要概念">Redis 指南(1)-重要概念</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-05T06:09:12.000Z" title="发表于 2023-06-05 14:09:12">2023-06-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">Redis 持久化机制
Redis 持久化机制主要分为 RDB 和 AOF 两种，当 Redis 重启时，系统会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整

RDBRDB持久化RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储


优点保存的是真实数据，一旦出现灾难性故障可以较容易地恢复数据。另外BGSAVE 是 fork 出子进程完成持久化的工作，这样就可以极大的避免服务进程执行IO操作，提高性能。在服务启动时，数据较大的话 RDB 的启动效率较高
缺点系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失


RDB持久化配置配置文件 *.conf 中可进行相关配置，默认开启



配置
作用



save 900 1
在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照


save 300 10
在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照
 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">nathan.yang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yang00-74"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to nathan blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/OpenSIPS-4/" title="OpenSIPS OutOfMemory 崩溃处理">OpenSIPS OutOfMemory 崩溃处理</a><time datetime="2023-09-13T07:20:29.000Z" title="发表于 2023-09-13 15:20:29">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/02/OpenSIPS-3/" title="OpenSIPS 管理接口的对接">OpenSIPS 管理接口的对接</a><time datetime="2023-09-02T05:25:56.000Z" title="发表于 2023-09-02 13:25:56">2023-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/29/Rtpengine-1/" title="RTPEngine 通过 HTTP 获取指标的方式">RTPEngine 通过 HTTP 获取指标的方式</a><time datetime="2023-08-29T07:10:34.000Z" title="发表于 2023-08-29 15:10:34">2023-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/26/SIP-1/" title="SIP 协议路由规则详解">SIP 协议路由规则详解</a><time datetime="2023-08-26T07:13:25.000Z" title="发表于 2023-08-26 15:13:25">2023-08-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/25/OpenSIPS-2/" title="OpenSIPS 通话中 UPDATE 请求导致没有声音问题">OpenSIPS 通话中 UPDATE 请求导致没有声音问题</a><time datetime="2023-08-25T09:58:32.000Z" title="发表于 2023-08-25 17:58:32">2023-08-25</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">Java 基础</span><span class="card-category-list-count">6</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/JVM/"><span class="card-category-list-name">JVM</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/Java-%E5%B9%B6%E5%8F%91/"><span class="card-category-list-name">Java 并发</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="card-category-list-name">Netty 源码分析</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/OpenSIPS/"><span class="card-category-list-name">OpenSIPS</span><span class="card-category-list-count">4</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/OpenSIPS/OpenSIPS-%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/"><span class="card-category-list-name">OpenSIPS 使用备忘</span><span class="card-category-list-count">4</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">15</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/Redis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">Redis 源码阅读笔记</span><span class="card-category-list-count">13</span></a></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Java-%E5%9F%BA%E7%A1%80/" style="font-size: 1.33em; color: #99a2af">Java 基础</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.27em; color: #99a0a9">分布式</a> <a href="/tags/Netty/" style="font-size: 1.21em; color: #999ea4">Netty</a> <a href="/tags/Redis/" style="font-size: 1.5em; color: #99a9bf">Redis</a> <a href="/tags/Spring/" style="font-size: 1.1em; color: #999">Spring</a> <a href="/tags/SIP-%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/" style="font-size: 1.21em; color: #999ea4">SIP 协议相关</a> <a href="/tags/Tomcat/" style="font-size: 1.16em; color: #999b9e">Tomcat</a> <a href="/tags/OpenSIPS/" style="font-size: 1.21em; color: #999ea4">OpenSIPS</a> <a href="/tags/rtp-%E4%BB%A3%E7%90%86/" style="font-size: 1.1em; color: #999">rtp 代理</a> <a href="/tags/Git/" style="font-size: 1.16em; color: #999b9e">Git</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.16em; color: #999b9e">多线程</a> <a href="/tags/Java/" style="font-size: 1.44em; color: #99a7ba">Java</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.39em; color: #99a4b4">数据结构</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/" style="font-size: 1.16em; color: #999b9e">工具配置</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">21</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><span class="card-archive-list-count">11</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">38</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-09-13T09:47:44.033Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By nathan.yang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="点,啥,呢" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>